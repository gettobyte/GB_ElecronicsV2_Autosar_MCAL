
Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20/151 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20) @06e1c2a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/104 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20/150 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20) @06e1c1c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/104 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10/149 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10) @06e05e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/102 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10/148 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10) @06e05d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/102 
  Calls: 
FlexCAN_SetErrIntCmd/147 (FlexCAN_SetErrIntCmd) @06e058c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_SetErrorInt_Privileged/98 
  Calls: 
FlexCAN_DisableInterrupts/146 (FlexCAN_DisableInterrupts) @06e05620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_DisableInterrupts_Privileged/97 
  Calls: 
FlexCAN_EnableInterrupts/145 (FlexCAN_EnableInterrupts) @06e05460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_EnableInterrupts_Privileged/96 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17/144 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17) @06e05000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17/143 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17) @06df7ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16/142 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16) @06df7c40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/92 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16/141 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16) @06df7b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/92 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15/140 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15) @06df7700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/90 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15/139 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15) @06df7620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/90 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09/138 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09) @06df72a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ClearTDCFail/87 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09/137 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09) @06df71c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ClearTDCFail/87 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14/136 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14) @06de7c40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrate_Privileged/85 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14/135 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14) @06de7b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrate_Privileged/85 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08/134 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08) @06de78c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetRxMaskType_Privileged/84 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08/133 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08) @06de77e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetRxMaskType_Privileged/84 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07/132 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07) @06de7540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStartMode_Privileged/82 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07/131 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07) @06de7460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStartMode_Privileged/82 
  Calls: 
FlexCAN_ExitFreezeMode/130 (FlexCAN_ExitFreezeMode) @06dca8c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStartMode_Privileged/82 FlexCAN_Ip_ExitFreezeMode_Privileged/73 
  Calls: 
FlexCAN_SetRxFifoFilter/129 (FlexCAN_SetRxFifoFilter) @06db4460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRxFifo_Privileged/59 
  Calls: 
FlexCAN_Enable/128 (FlexCAN_Enable) @06db4380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/102 FlexCAN_Ip_SetRxMb15Mask_Privileged/101 FlexCAN_Ip_SetRxMb14Mask_Privileged/100 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 FlexCAN_Ip_SetTDCOffset_Privileged/92 FlexCAN_Ip_SetBitrateCbt_Privileged/90 FlexCAN_Ip_SetBitrate_Privileged/85 FlexCAN_Ip_SetRxMaskType_Privileged/84 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/75 FlexCAN_Ip_SetRxIndividualMask_Privileged/74 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/71 FlexCAN_Ip_ConfigRxFifo_Privileged/59 
  Calls: 
FlexCAN_SetRxMsgBuff/127 (FlexCAN_SetRxMsgBuff) @06d96d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRxMb/54 FlexCAN_Ip_ConfigRxMb/54 FlexCAN_Ip_ConfigRxMb/54 
  Calls: 
FlexCAN_SetOperationMode/126 (FlexCAN_SetOperationMode) @06d96620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_Init_Privileged/52 
  Calls: 
FLEXCAN_ClearMsgBuffIntCmd/125 (FLEXCAN_ClearMsgBuffIntCmd) @06d96380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_AbortTransfer/99 FlexCAN_AbortRxTransfer/51 
  Calls: 
FlexCAN_GetMsgBuffTimestamp/124 (FlexCAN_GetMsgBuffTimestamp) @06d960e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_MainFunctionWrite/79 FlexCAN_IRQHandlerTxMB/47 
  Calls: 
FlexCAN_GetMsgBuff/123 (FlexCAN_GetMsgBuff) @06d84e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_IRQHandlerTxMB/47 FlexCAN_IRQHandlerRxMB/46 
  Calls: 
FlexCAN_LockRxMsgBuff/122 (FlexCAN_LockRxMsgBuff) @06d84d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_IRQHandlerTxMB/47 FlexCAN_IRQHandlerRxMB/46 
  Calls: 
FlexCAN_SetTxMsgBuff/121 (FlexCAN_SetTxMsgBuff) @06d849a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_StartSendData/44 
  Calls: 
FlexCAN_GetMsgBuffRegion/120 (FlexCAN_GetMsgBuffRegion) @06d848c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SendBlocking/70 FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_AbortRxTransfer/51 FlexCAN_AbortRxTransfer/51 FlexCAN_AbortTxTransfer/50 FlexCAN_IRQHandlerRxMB/46 FlexCAN_StartSendData/44 
  Calls: 
FlexCAN_GetMbPayloadSize/119 (FlexCAN_GetMbPayloadSize) @06d847e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_StartSendData/44 
  Calls: 
FlexCAN_IsMbOutOfRange/118 (FlexCAN_IsMbOutOfRange) @06d84540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_Ip_ConfigRxMb/54 FlexCAN_StartSendData/44 FlexCAN_StartRxMessageBufferData/43 
  Calls: 
FlexCAN_ReadRxFifo/117 (FlexCAN_ReadRxFifo) @06d842a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_IRQHandlerRxFIFO/48 
  Calls: 
FlexCAN_SetMsgBuffIntCmd/116 (FlexCAN_SetMsgBuffIntCmd) @06d84000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_ProccessLegacyRxFIFO/42 FlexCAN_ProccessLegacyRxFIFO/42 FlexCAN_ProccessLegacyRxFIFO/42 FlexCAN_CompleteRxMessageFifoData/62 FlexCAN_CompleteRxMessageFifoData/62 FlexCAN_CompleteRxMessageFifoData/62 FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_Ip_ReceiveBlocking/56 FlexCAN_Ip_ReceiveBlocking/56 FlexCAN_Ip_Receive/55 FlexCAN_Ip_Send/53 FlexCAN_IRQHandlerTxMB/47 FlexCAN_IRQHandlerTxMB/47 FlexCAN_IRQHandlerRxMB/46 FlexCAN_IRQHandlerRxMB/46 FlexCAN_StartRxMessageFifoData/45 FlexCAN_StartRxMessageFifoData/45 FlexCAN_StartRxMessageFifoData/45 
  Calls: 
OsIf_GetElapsed/115 (OsIf_GetElapsed) @06d65ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/104 FlexCAN_Ip_SendBlocking/70 FlexCAN_Ip_SendBlocking/70 FlexCAN_ProccessLegacyRxFIFO/42 FlexCAN_Ip_ReceiveBlocking/56 FlexCAN_AbortTxTransfer/50 
  Calls: 
OsIf_GetCounter/114 (OsIf_GetCounter) @06d65e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/104 FlexCAN_Ip_SendBlocking/70 FlexCAN_Ip_SendBlocking/70 FlexCAN_ProccessLegacyRxFIFO/42 FlexCAN_Ip_ReceiveBlocking/56 FlexCAN_AbortTxTransfer/50 
  Calls: 
OsIf_MicrosToTicks/113 (OsIf_MicrosToTicks) @06d65d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/104 FlexCAN_Ip_SendBlocking/70 FlexCAN_Ip_SendBlocking/70 FlexCAN_ProccessLegacyRxFIFO/42 FlexCAN_Ip_ReceiveBlocking/56 FlexCAN_AbortTxTransfer/50 
  Calls: 
FlexCAN_ConfigCtrlOptions/112 (FlexCAN_ConfigCtrlOptions) @06d657e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitController/41 
  Calls: 
FlexCAN_IsFDAvailable/111 (FlexCAN_IsFDAvailable) @06d65700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/92 FlexCAN_Ip_Init_Privileged/52 FlexCAN_InitController/41 FlexCAN_SetRegDefaultVal/36 
  Calls: 
FlexCAN_Init/110 (FlexCAN_Init) @06d65620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitController/41 
  Calls: 
FlexCAN_SetMaxMsgBuffNum/109 (FlexCAN_SetMaxMsgBuffNum) @06d65380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitCtroll/40 
  Calls: 
FlexCAN_SetPayloadSize/108 (FlexCAN_SetPayloadSize) @06d652a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitCtroll/40 
  Calls: 
FlexCAN_Disable/107 (FlexCAN_Disable) @06d651c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/102 FlexCAN_Ip_SetRxMb15Mask_Privileged/101 FlexCAN_Ip_SetRxMb14Mask_Privileged/100 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 FlexCAN_Ip_SetTDCOffset_Privileged/92 FlexCAN_Ip_SetBitrateCbt_Privileged/90 FlexCAN_Ip_SetBitrate_Privileged/85 FlexCAN_Ip_SetRxMaskType_Privileged/84 FlexCAN_Ip_SetStopMode_Privileged/83 FlexCAN_Ip_Deinit_Privileged/76 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/75 FlexCAN_Ip_SetRxIndividualMask_Privileged/74 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/71 FlexCAN_Ip_ConfigRxFifo_Privileged/59 FlexCAN_InitController/41 FlexCAN_InitController/41 FlexCAN_InitCtroll/40 FlexCAN_InitCtroll/40 
  Calls: 
FlexCAN_EnterFreezeMode/106 (FlexCAN_EnterFreezeMode) @06d650e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStopMode_Privileged/83 FlexCAN_Ip_Deinit_Privileged/76 FlexCAN_Ip_EnterFreezeMode_Privileged/72 FlexCAN_InitController/41 FlexCAN_InitController/41 FlexCAN_InitCtroll/40 FlexCAN_InitCtroll/40 
  Calls: 
FlexCAN_EnableRxFifo/105 (FlexCAN_EnableRxFifo) @06d5ce00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitRxFifo/39 
  Calls: 
FlexCAN_Ip_ManualBusOffRecovery/104 (FlexCAN_Ip_ManualBusOffRecovery) @06d5c0e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: OsIf_GetElapsed/115 OsIf_GetCounter/114 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20/151 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20/150 DevAssert/0 OsIf_MicrosToTicks/113 
FlexCAN_Ip_GetListenOnlyMode/103 (FlexCAN_Ip_GetListenOnlyMode) @06d5cd20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IsListenOnlyModeEnabled/20 
FlexCAN_Ip_SetListenOnlyMode_Privileged/102 (FlexCAN_Ip_SetListenOnlyMode_Privileged) @06d5ca80
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10/149 FlexCAN_SetListenOnlyMode/5 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10/148 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_SetRxMb15Mask_Privileged/101 (FlexCAN_Ip_SetRxMb15Mask_Privileged) @06d5c7e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_SetRxMb14Mask_Privileged/100 (FlexCAN_Ip_SetRxMb14Mask_Privileged) @06d5c540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_AbortTransfer/99 (FlexCAN_Ip_AbortTransfer) @06d5c2a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_AbortRxTransfer/51 FlexCAN_AbortTxTransfer/50 FLEXCAN_ClearMsgBuffIntCmd/125 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetErrorInt_Privileged/98 (FlexCAN_Ip_SetErrorInt_Privileged) @06d5c000
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 DevAssert/0 FlexCAN_SetErrIntCmd/147 FlexCAN_IsFreezeMode/33 FlexCAN_SetErrIntCmd/147 FlexCAN_IsFreezeMode/33 FlexCAN_SetErrIntCmd/147 FlexCAN_SetErrIntCmd/147 FlexCAN_SetErrIntCmd/147 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_DisableInterrupts_Privileged/97 (FlexCAN_Ip_DisableInterrupts_Privileged) @06d51b60
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_DisableInterrupts/146 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_EnableInterrupts_Privileged/96 (FlexCAN_Ip_EnableInterrupts_Privileged) @06d51620
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_EnableInterrupts/145 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_ClearBuffStatusFlag/95 (FlexCAN_Ip_ClearBuffStatusFlag) @06d510e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/7 DevAssert/0 
FlexCAN_Ip_GetBuffStatusFlag/94 (FlexCAN_Ip_GetBuffStatusFlag) @06d51d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_GetBuffStatusFlag/8 DevAssert/0 
FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 (FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged) @06d51a80
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17/144 FlexCAN_SetTxArbitrationStartDelay/34 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17/143 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_SetTDCOffset_Privileged/92 (FlexCAN_Ip_SetTDCOffset_Privileged) @06d517e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16/142 FlexCAN_SetTDCOffset/2 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16/141 FlexCAN_IsFreezeMode/33 DevAssert/0 FlexCAN_IsFDAvailable/111 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_GetBitrateFD/91 (FlexCAN_Ip_GetBitrateFD) @06d51540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_GetFDTimeSegments/15 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetBitrateCbt_Privileged/90 (FlexCAN_Ip_SetBitrateCbt_Privileged) @06d512a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15/140 FlexCAN_SetFDTimeSegments/10 FlexCAN_SetFDEnabled/4 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15/139 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsFDEnabled/19 FlexCAN_IsEnabled/3 DevAssert/0 DevAssert/0 
FlexCAN_Ip_GetTDCValue/89 (FlexCAN_Ip_GetTDCValue) @06d51000
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_GetTDCFail/88 (FlexCAN_Ip_GetTDCFail) @06d49b60
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_ClearTDCFail/87 (FlexCAN_Ip_ClearTDCFail) @06d49620
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09/138 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09/137 DevAssert/0 
FlexCAN_Ip_GetBitrate/86 (FlexCAN_Ip_GetBitrate) @06d490e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_GetTimeSegments/14 FlexCAN_GetExtendedTimeSegments/13 FlexCAN_IsExCbtEnabled/16 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetBitrate_Privileged/85 (FlexCAN_Ip_SetBitrate_Privileged) @06d49d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14/136 FlexCAN_SetTimeSegments/11 FlexCAN_SetExtendedTimeSegments/12 FlexCAN_IsExCbtEnabled/16 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14/135 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetRxMaskType_Privileged/84 (FlexCAN_Ip_SetRxMaskType_Privileged) @06d49a80
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08/134 FlexCAN_SetRxMaskType/35 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08/133 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_SetStopMode_Privileged/83 (FlexCAN_Ip_SetStopMode_Privileged) @06d497e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 FlexCAN_EnterFreezeMode/106 DevAssert/0 
FlexCAN_Ip_SetStartMode_Privileged/82 (FlexCAN_Ip_SetStartMode_Privileged) @06d49540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ExitFreezeMode/130 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07/132 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07/131 DevAssert/0 
FlexCAN_Ip_GetStartMode_Privileged/81 (FlexCAN_Ip_GetStartMode_Privileged) @06d492a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
FlexCAN_Ip_GetStopMode_Privileged/80 (FlexCAN_Ip_GetStopMode_Privileged) @06d49000
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
FlexCAN_Ip_MainFunctionWrite/79 (FlexCAN_Ip_MainFunctionWrite) @06d3db60
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_UnlockRxMsgBuff/6 FlexCAN_GetMsgBuffTimestamp/124 FlexCAN_GetBuffStatusFlag/8 DevAssert/0 
FlexCAN_Ip_MainFunctionBusOff_Privileged/78 (FlexCAN_Ip_MainFunctionBusOff_Privileged) @06d3d620
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
   Indirect call
FlexCAN_Ip_MainFunctionRead/77 (FlexCAN_Ip_MainFunctionRead) @06d3d0e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IRQHandlerRxMB/46 FlexCAN_GetBuffStatusFlag/8 FlexCAN_IRQHandlerRxFIFO/48 FlexCAN_GetBuffStatusFlag/8 DevAssert/0 DevAssert/0 
FlexCAN_Ip_Deinit_Privileged/76 (FlexCAN_Ip_Deinit_Privileged) @06d3dd20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (write)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 FlexCAN_SetRegDefaultVal/36 FlexCAN_EnterFreezeMode/106 DevAssert/0 
FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/75 (FlexCAN_Ip_SetRxFifoGlobalMask_Privileged) @06d3da80
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 FlexCAN_SetRxFifoGlobalMask/1 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_SetRxIndividualMask_Privileged/74 (FlexCAN_Ip_SetRxIndividualMask_Privileged) @06d3d7e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 FlexCAN_SetRxIndividualMask/32 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_ExitFreezeMode_Privileged/73 (FlexCAN_Ip_ExitFreezeMode_Privileged) @06d3d540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ExitFreezeMode/130 
FlexCAN_Ip_EnterFreezeMode_Privileged/72 (FlexCAN_Ip_EnterFreezeMode_Privileged) @06d3d2a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_EnterFreezeMode/106 
FlexCAN_Ip_SetRxMbGlobalMask_Privileged/71 (FlexCAN_Ip_SetRxMbGlobalMask_Privileged) @06d3d000
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 FlexCAN_SetRxMsgBuffGlobalMask/31 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_SendBlocking/70 (FlexCAN_Ip_SendBlocking) @06d2eb60
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_GetBuffStatusFlag/8 OsIf_GetElapsed/115 OsIf_GetCounter/114 OsIf_MicrosToTicks/113 FlexCAN_GetMsgBuffRegion/120 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_GetBuffStatusFlag/8 OsIf_GetElapsed/115 OsIf_GetCounter/114 FlexCAN_StartSendData/44 DevAssert/0 DevAssert/0 OsIf_MicrosToTicks/113 
FlexCAN_BusOff_IRQHandler/69 (FlexCAN_BusOff_IRQHandler) @06d2e620
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
   Indirect call
   Indirect call
   Indirect call
FlexCAN_Error_IRQHandler/68 (FlexCAN_Error_IRQHandler) @06d2e0e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
   Indirect call
   Indirect call
FlexCAN_Ip_GetControllerRxErrorCounter/67 (FlexCAN_Ip_GetControllerRxErrorCounter) @06d2ed20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_GetControllerTxErrorCounter/66 (FlexCAN_Ip_GetControllerTxErrorCounter) @06d2ea80
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_GetErrorStatus/65 (FlexCAN_Ip_GetErrorStatus) @06d2e7e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_ClearErrorStatus/64 (FlexCAN_Ip_ClearErrorStatus) @06d2e540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_IRQHandler/63 (FlexCAN_IRQHandler) @06d2e2a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_ProcessSpuriousInterruptMB/49 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_GetMsgBuffIntStatusFlag/30 FlexCAN_IRQHandlerTxMB/47 FlexCAN_IRQHandlerRxMB/46 FlexCAN_IRQHandlerRxFIFO/48 FlexCAN_GetMsgBuffIntStatusFlag/30 FlexCAN_GetMsgBuffIntStatusFlag/30 DevAssert/0 DevAssert/0 
FlexCAN_CompleteRxMessageFifoData/62 (FlexCAN_CompleteRxMessageFifoData) @06d2e000
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_IRQHandlerRxFIFO/48 
  Calls: FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_SetMsgBuffIntCmd/116 DevAssert/0 
FlexCAN_Ip_GetTransferStatus/61 (FlexCAN_Ip_GetTransferStatus) @06d1fb60
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 DevAssert/0 
FlexCAN_Ip_ConfigRemoteResponseMb/60 (FlexCAN_Ip_ConfigRemoteResponseMb) @06d1f620
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_SetTxMsgBuff/121 FlexCAN_GetMsgBuffRegion/120 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_IsMbOutOfRange/118 DevAssert/0 FlexCAN_GetMbPayloadSize/119 DevAssert/0 DevAssert/0 DevAssert/0 
FlexCAN_Ip_ConfigRxFifo_Privileged/59 (FlexCAN_Ip_ConfigRxFifo_Privileged) @06d1f0e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/107 FlexCAN_SetRxFifoFilter/129 FlexCAN_IsFreezeMode/33 FlexCAN_Enable/128 FlexCAN_IsEnabled/3 DevAssert/0 
FlexCAN_Ip_RxFifoBlocking/58 (FlexCAN_Ip_RxFifoBlocking) @06d1fd20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ProccessLegacyRxFIFO/42 FlexCAN_StartRxMessageFifoData/45 DevAssert/0 
FlexCAN_Ip_RxFifo/57 (FlexCAN_Ip_RxFifo) @06d1fa80
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_StartRxMessageFifoData/45 DevAssert/0 
FlexCAN_Ip_ReceiveBlocking/56 (FlexCAN_Ip_ReceiveBlocking) @06d1f7e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxState/38 (read)Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/116 OsIf_GetElapsed/115 FlexCAN_IRQHandlerRxMB/46 FlexCAN_GetBuffStatusFlag/8 OsIf_GetCounter/114 FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_StartRxMessageBufferData/43 DevAssert/0 OsIf_MicrosToTicks/113 
FlexCAN_Ip_Receive/55 (FlexCAN_Ip_Receive) @06d1f540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_StartRxMessageBufferData/43 DevAssert/0 
FlexCAN_Ip_ConfigRxMb/54 (FlexCAN_Ip_ConfigRxMb) @06d1f2a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetRxMsgBuff/127 FlexCAN_SetRxMsgBuff/127 FlexCAN_SetRxMsgBuff/127 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_IsMbOutOfRange/118 DevAssert/0 DevAssert/0 
FlexCAN_Ip_Send/53 (FlexCAN_Ip_Send) @06d1f000
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_StartSendData/44 FlexCAN_IsListenOnlyModeEnabled/20 DevAssert/0 DevAssert/0 
FlexCAN_Ip_Init_Privileged/52 (FlexCAN_Ip_Init_Privileged) @06d09b60
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (write)
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetOperationMode/126 FlexCAN_SetTimeSegments/11 FlexCAN_SetFDTimeSegments/10 FlexCAN_SetExtendedTimeSegments/12 FlexCAN_EnableExtCbt/17 FlexCAN_InitController/41 DevAssert/0 FlexCAN_IsFDAvailable/111 DevAssert/0 DevAssert/0 
FlexCAN_AbortRxTransfer/51 (FlexCAN_AbortRxTransfer) @06d09620
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_AbortTransfer/99 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_GetMsgBuffRegion/120 FLEXCAN_ClearMsgBuffIntCmd/125 FlexCAN_GetMsgBuffRegion/120 RxFifoOcuppiedLastMsgBuff/21 
FlexCAN_AbortTxTransfer/50 (FlexCAN_AbortTxTransfer) @06d090e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_AbortTransfer/99 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_GetBuffStatusFlag/8 OsIf_GetElapsed/115 OsIf_GetCounter/114 OsIf_MicrosToTicks/113 FlexCAN_GetMsgBuffRegion/120 
FlexCAN_ProcessSpuriousInterruptMB/49 (FlexCAN_ProcessSpuriousInterruptMB) @06d09d20
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_IRQHandler/63 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_GetBuffStatusImask/9 FlexCAN_GetBuffStatusFlag/8 
FlexCAN_IRQHandlerRxFIFO/48 (FlexCAN_IRQHandlerRxFIFO) @06d09a80
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_MainFunctionRead/77 FlexCAN_IRQHandler/63 FlexCAN_ProccessLegacyRxFIFO/42 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_CompleteRxMessageFifoData/62 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_ReadRxFifo/117 
   Indirect call
   Indirect call
   Indirect call
FlexCAN_IRQHandlerTxMB/47 (FlexCAN_IRQHandlerTxMB) @06d097e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_IRQHandler/63 
  Calls: FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_UnlockRxMsgBuff/6 FlexCAN_GetMsgBuffTimestamp/124 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_UnlockRxMsgBuff/6 FlexCAN_GetMsgBuff/123 FlexCAN_LockRxMsgBuff/122 
   Indirect call
FlexCAN_IRQHandlerRxMB/46 (FlexCAN_IRQHandlerRxMB) @06d09540
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_MainFunctionRead/77 FlexCAN_IRQHandler/63 FlexCAN_Ip_ReceiveBlocking/56 
  Calls: FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_UnlockRxMsgBuff/6 FlexCAN_GetMsgBuffRegion/120 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_GetMsgBuff/123 FlexCAN_LockRxMsgBuff/122 
   Indirect call
FlexCAN_StartRxMessageFifoData/45 (FlexCAN_StartRxMessageFifoData) @06d092a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/58 FlexCAN_Ip_RxFifo/57 
  Calls: FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_SetMsgBuffIntCmd/116 DevAssert/0 
FlexCAN_StartSendData/44 (FlexCAN_StartSendData) @06d09000
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxState/38 (read)Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_SendBlocking/70 FlexCAN_Ip_Send/53 
  Calls: FlexCAN_SetTxMsgBuff/121 FlexCAN_GetMsgBuffRegion/120 FlexCAN_ClearMsgBuffIntStatusFlag/7 FlexCAN_IsMbOutOfRange/118 DevAssert/0 FlexCAN_GetMbPayloadSize/119 DevAssert/0 DevAssert/0 
FlexCAN_StartRxMessageBufferData/43 (FlexCAN_StartRxMessageBufferData) @06c5ab60
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/37 (read)Flexcan_Ip_apxState/38 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_ReceiveBlocking/56 FlexCAN_Ip_Receive/55 
  Calls: FlexCAN_IsMbOutOfRange/118 DevAssert/0 
FlexCAN_ProccessLegacyRxFIFO/42 (FlexCAN_ProccessLegacyRxFIFO) @06c5a620
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxState/38 (read)Flexcan_Ip_apxBase/37 (read)
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/58 
  Calls: FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_SetMsgBuffIntCmd/116 FlexCAN_SetMsgBuffIntCmd/116 OsIf_GetElapsed/115 FlexCAN_IRQHandlerRxFIFO/48 FlexCAN_GetBuffStatusFlag/8 OsIf_GetCounter/114 OsIf_MicrosToTicks/113 
FlexCAN_InitController/41 (FlexCAN_InitController) @06c5ad20
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_Init_Privileged/52 
  Calls: FlexCAN_InitCtroll/40 FlexCAN_ConfigCtrlOptions/112 FlexCAN_SetFDEnabled/4 FlexCAN_IsFDAvailable/111 FlexCAN_Disable/107 FlexCAN_EnterFreezeMode/106 FlexCAN_Init/110 FlexCAN_SetClkSrc/29 FlexCAN_Disable/107 FlexCAN_EnterFreezeMode/106 FlexCAN_IsEnabled/3 
FlexCAN_InitCtroll/40 (FlexCAN_InitCtroll) @06c5aa80
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_InitController/41 
  Calls: FlexCAN_Disable/107 FlexCAN_EnterFreezeMode/106 FlexCAN_SetMaxMsgBuffNum/109 FlexCAN_SetPayloadSize/108 FlexCAN_Disable/107 FlexCAN_EnterFreezeMode/106 FlexCAN_InitRxFifo/39 FlexCAN_SetSelfReception/18 
FlexCAN_InitRxFifo/39 (FlexCAN_InitRxFifo) @06c5a7e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_InitCtroll/40 
  Calls: FlexCAN_EnableRxFifo/105 
Flexcan_Ip_apxState/38 (Flexcan_Ip_apxState) @06b5a558
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: FlexCAN_CompleteRxMessageFifoData/62 (read)FlexCAN_Ip_GetTransferStatus/61 (read)FlexCAN_Ip_DisableInterrupts_Privileged/97 (read)FlexCAN_ProcessSpuriousInterruptMB/49 (read)FlexCAN_StartRxMessageBufferData/43 (read)FlexCAN_StartSendData/44 (read)FlexCAN_StartRxMessageFifoData/45 (read)FlexCAN_IRQHandlerRxMB/46 (read)FlexCAN_IRQHandlerTxMB/47 (read)FlexCAN_AbortTxTransfer/50 (read)FlexCAN_AbortRxTransfer/51 (read)FlexCAN_Ip_Init_Privileged/52 (write)FlexCAN_Ip_Send/53 (read)FlexCAN_Ip_ConfigRxMb/54 (read)FlexCAN_Ip_Receive/55 (read)FlexCAN_Ip_ReceiveBlocking/56 (read)FlexCAN_Ip_ConfigRemoteResponseMb/60 (read)FlexCAN_IRQHandlerRxFIFO/48 (read)FlexCAN_Ip_EnableInterrupts_Privileged/96 (read)FlexCAN_ProccessLegacyRxFIFO/42 (read)FlexCAN_IRQHandler/63 (read)FlexCAN_Error_IRQHandler/68 (read)FlexCAN_BusOff_IRQHandler/69 (read)FlexCAN_Ip_SendBlocking/70 (read)FlexCAN_Ip_Deinit_Privileged/76 (write)FlexCAN_Ip_MainFunctionRead/77 (read)FlexCAN_Ip_MainFunctionBusOff_Privileged/78 (read)FlexCAN_Ip_MainFunctionWrite/79 (read)FlexCAN_Ip_AbortTransfer/99 (read)
  Availability: available
  Varpool flags:
Flexcan_Ip_apxBase/37 (Flexcan_Ip_apxBase) @06b5a4c8
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: FlexCAN_CompleteRxMessageFifoData/62 (read)FlexCAN_Ip_ConfigRemoteResponseMb/60 (read)FlexCAN_Ip_GetListenOnlyMode/103 (read)FlexCAN_ProcessSpuriousInterruptMB/49 (read)FlexCAN_StartRxMessageBufferData/43 (read)FlexCAN_StartSendData/44 (read)FlexCAN_StartRxMessageFifoData/45 (read)FlexCAN_IRQHandlerRxMB/46 (read)FlexCAN_IRQHandlerTxMB/47 (read)FlexCAN_AbortTxTransfer/50 (read)FlexCAN_AbortRxTransfer/51 (read)FlexCAN_Ip_Init_Privileged/52 (read)FlexCAN_Ip_Send/53 (read)FlexCAN_Ip_ConfigRxMb/54 (read)FlexCAN_Ip_Receive/55 (read)FlexCAN_Ip_ReceiveBlocking/56 (read)FlexCAN_Ip_ConfigRxFifo_Privileged/59 (read)FlexCAN_IRQHandlerRxFIFO/48 (read)FlexCAN_Ip_SetListenOnlyMode_Privileged/102 (read)FlexCAN_ProccessLegacyRxFIFO/42 (read)FlexCAN_IRQHandler/63 (read)FlexCAN_Ip_ClearErrorStatus/64 (read)FlexCAN_Ip_GetErrorStatus/65 (read)FlexCAN_Ip_GetControllerTxErrorCounter/66 (read)FlexCAN_Ip_GetControllerRxErrorCounter/67 (read)FlexCAN_Error_IRQHandler/68 (read)FlexCAN_BusOff_IRQHandler/69 (read)FlexCAN_Ip_SendBlocking/70 (read)FlexCAN_Ip_SetRxMbGlobalMask_Privileged/71 (read)FlexCAN_Ip_EnterFreezeMode_Privileged/72 (read)FlexCAN_Ip_ExitFreezeMode_Privileged/73 (read)FlexCAN_Ip_SetRxIndividualMask_Privileged/74 (read)FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/75 (read)FlexCAN_Ip_Deinit_Privileged/76 (read)FlexCAN_Ip_MainFunctionRead/77 (read)FlexCAN_Ip_MainFunctionBusOff_Privileged/78 (read)FlexCAN_Ip_MainFunctionWrite/79 (read)FlexCAN_Ip_GetStopMode_Privileged/80 (read)FlexCAN_Ip_GetStartMode_Privileged/81 (read)FlexCAN_Ip_SetStartMode_Privileged/82 (read)FlexCAN_Ip_SetStopMode_Privileged/83 (read)FlexCAN_Ip_SetRxMaskType_Privileged/84 (read)FlexCAN_Ip_SetBitrate_Privileged/85 (read)FlexCAN_Ip_GetBitrate/86 (read)FlexCAN_Ip_ClearTDCFail/87 (read)FlexCAN_Ip_GetTDCFail/88 (read)FlexCAN_Ip_GetTDCValue/89 (read)FlexCAN_Ip_SetBitrateCbt_Privileged/90 (read)FlexCAN_Ip_GetBitrateFD/91 (read)FlexCAN_Ip_SetTDCOffset_Privileged/92 (read)FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 (read)FlexCAN_Ip_GetBuffStatusFlag/94 (read)FlexCAN_Ip_ClearBuffStatusFlag/95 (read)FlexCAN_Ip_EnableInterrupts_Privileged/96 (read)FlexCAN_Ip_DisableInterrupts_Privileged/97 (read)FlexCAN_Ip_SetErrorInt_Privileged/98 (read)FlexCAN_Ip_AbortTransfer/99 (read)FlexCAN_Ip_SetRxMb14Mask_Privileged/100 (read)FlexCAN_Ip_SetRxMb15Mask_Privileged/101 (read)FlexCAN_Ip_ManualBusOffRecovery/104 (read)
  Availability: available
  Varpool flags: initialized read-only const-value-known
FlexCAN_SetRegDefaultVal/36 (FlexCAN_SetRegDefaultVal) @06b4b2a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_Deinit_Privileged/76 
  Calls: FlexCAN_IsFDAvailable/111 
FlexCAN_SetRxMaskType/35 (FlexCAN_SetRxMaskType) @06b46ee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxMaskType_Privileged/84 
  Calls: 
FlexCAN_SetTxArbitrationStartDelay/34 (FlexCAN_SetTxArbitrationStartDelay) @06b46a80
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 
  Calls: 
FlexCAN_IsFreezeMode/33 (FlexCAN_IsFreezeMode) @06b46700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/102 FlexCAN_Ip_SetRxMb15Mask_Privileged/101 FlexCAN_Ip_SetRxMb14Mask_Privileged/100 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 FlexCAN_Ip_SetTDCOffset_Privileged/92 FlexCAN_Ip_SetBitrateCbt_Privileged/90 FlexCAN_Ip_SetBitrate_Privileged/85 FlexCAN_Ip_SetRxMaskType_Privileged/84 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/75 FlexCAN_Ip_SetRxIndividualMask_Privileged/74 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/71 FlexCAN_Ip_ConfigRxFifo_Privileged/59 
  Calls: 
FlexCAN_SetRxIndividualMask/32 (FlexCAN_SetRxIndividualMask) @06b46460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxIndividualMask_Privileged/74 
  Calls: 
FlexCAN_SetRxMsgBuffGlobalMask/31 (FlexCAN_SetRxMsgBuffGlobalMask) @06b461c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxMbGlobalMask_Privileged/71 
  Calls: 
FlexCAN_GetMsgBuffIntStatusFlag/30 (FlexCAN_GetMsgBuffIntStatusFlag) @06b41ee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_IRQHandler/63 FlexCAN_IRQHandler/63 FlexCAN_IRQHandler/63 
  Calls: 
FlexCAN_SetClkSrc/29 (FlexCAN_SetClkSrc) @06b41c40
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_InitController/41 
  Calls: 
RxFifoOcuppiedLastMsgBuff/21 (RxFifoOcuppiedLastMsgBuff) @06cb2ee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_AbortRxTransfer/51 
  Calls: 
FlexCAN_IsListenOnlyModeEnabled/20 (FlexCAN_IsListenOnlyModeEnabled) @06cb2c40
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetListenOnlyMode/103 FlexCAN_Ip_Send/53 
  Calls: 
FlexCAN_IsFDEnabled/19 (FlexCAN_IsFDEnabled) @06cb29a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/90 
  Calls: 
FlexCAN_SetSelfReception/18 (FlexCAN_SetSelfReception) @06cb2700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_InitCtroll/40 
  Calls: 
FlexCAN_EnableExtCbt/17 (FlexCAN_EnableExtCbt) @06cb22a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_Init_Privileged/52 
  Calls: 
FlexCAN_IsExCbtEnabled/16 (FlexCAN_IsExCbtEnabled) @06cadee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/86 FlexCAN_Ip_SetBitrate_Privileged/85 
  Calls: 
FlexCAN_GetFDTimeSegments/15 (FlexCAN_GetFDTimeSegments) @06cadc40
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrateFD/91 
  Calls: 
FlexCAN_GetTimeSegments/14 (FlexCAN_GetTimeSegments) @06cad9a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/86 
  Calls: 
FlexCAN_GetExtendedTimeSegments/13 (FlexCAN_GetExtendedTimeSegments) @06cad700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/86 
  Calls: 
FlexCAN_SetExtendedTimeSegments/12 (FlexCAN_SetExtendedTimeSegments) @06cad460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/85 FlexCAN_Ip_Init_Privileged/52 
  Calls: DevAssert/0 
FlexCAN_SetTimeSegments/11 (FlexCAN_SetTimeSegments) @06ca7d20
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/85 FlexCAN_Ip_Init_Privileged/52 
  Calls: DevAssert/0 
FlexCAN_SetFDTimeSegments/10 (FlexCAN_SetFDTimeSegments) @06ca7620
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/90 FlexCAN_Ip_Init_Privileged/52 
  Calls: DevAssert/0 
FlexCAN_GetBuffStatusImask/9 (FlexCAN_GetBuffStatusImask) @06ca3ee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_ProcessSpuriousInterruptMB/49 
  Calls: 
FlexCAN_GetBuffStatusFlag/8 (FlexCAN_GetBuffStatusFlag) @06ca3c40
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBuffStatusFlag/94 FlexCAN_Ip_MainFunctionWrite/79 FlexCAN_Ip_MainFunctionRead/77 FlexCAN_Ip_MainFunctionRead/77 FlexCAN_Ip_SendBlocking/70 FlexCAN_Ip_SendBlocking/70 FlexCAN_ProccessLegacyRxFIFO/42 FlexCAN_Ip_ReceiveBlocking/56 FlexCAN_AbortTxTransfer/50 FlexCAN_ProcessSpuriousInterruptMB/49 
  Calls: 
FlexCAN_ClearMsgBuffIntStatusFlag/7 (FlexCAN_ClearMsgBuffIntStatusFlag) @06ca39a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_ClearBuffStatusFlag/95 FlexCAN_Ip_MainFunctionWrite/79 FlexCAN_Ip_SendBlocking/70 FlexCAN_Ip_SendBlocking/70 FlexCAN_IRQHandler/63 FlexCAN_IRQHandler/63 FlexCAN_IRQHandlerRxFIFO/48 FlexCAN_IRQHandlerRxFIFO/48 FlexCAN_IRQHandlerRxFIFO/48 FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_Ip_ConfigRxMb/54 FlexCAN_AbortRxTransfer/51 FlexCAN_AbortTxTransfer/50 FlexCAN_IRQHandlerTxMB/47 FlexCAN_IRQHandlerTxMB/47 FlexCAN_IRQHandlerRxMB/46 FlexCAN_StartSendData/44 FlexCAN_ProcessSpuriousInterruptMB/49 
  Calls: 
FlexCAN_UnlockRxMsgBuff/6 (FlexCAN_UnlockRxMsgBuff) @06ca3700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_MainFunctionWrite/79 FlexCAN_IRQHandlerTxMB/47 FlexCAN_IRQHandlerTxMB/47 FlexCAN_IRQHandlerRxMB/46 
  Calls: 
FlexCAN_SetListenOnlyMode/5 (FlexCAN_SetListenOnlyMode) @06ca3380
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/102 
  Calls: 
FlexCAN_SetFDEnabled/4 (FlexCAN_SetFDEnabled) @06ca3000
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/90 FlexCAN_InitController/41 
  Calls: 
FlexCAN_IsEnabled/3 (FlexCAN_IsEnabled) @06c9eb60
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/102 FlexCAN_Ip_SetRxMb15Mask_Privileged/101 FlexCAN_Ip_SetRxMb14Mask_Privileged/100 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_DisableInterrupts_Privileged/97 FlexCAN_Ip_EnableInterrupts_Privileged/96 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 FlexCAN_Ip_SetTDCOffset_Privileged/92 FlexCAN_Ip_SetBitrateCbt_Privileged/90 FlexCAN_Ip_SetBitrate_Privileged/85 FlexCAN_Ip_SetRxMaskType_Privileged/84 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/75 FlexCAN_Ip_SetRxIndividualMask_Privileged/74 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/71 FlexCAN_Ip_ConfigRxFifo_Privileged/59 FlexCAN_InitController/41 
  Calls: 
FlexCAN_SetTDCOffset/2 (FlexCAN_SetTDCOffset) @06c9e700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/92 
  Calls: 
FlexCAN_SetRxFifoGlobalMask/1 (FlexCAN_SetRxFifoGlobalMask) @06c9e380
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/75 
  Calls: 
DevAssert/0 (DevAssert) @06c7b2a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_ManualBusOffRecovery/104 FlexCAN_Ip_SetListenOnlyMode_Privileged/102 FlexCAN_Ip_SetRxMb15Mask_Privileged/101 FlexCAN_Ip_SetRxMb14Mask_Privileged/100 FlexCAN_Ip_AbortTransfer/99 FlexCAN_Ip_AbortTransfer/99 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_SetErrorInt_Privileged/98 FlexCAN_Ip_DisableInterrupts_Privileged/97 FlexCAN_Ip_EnableInterrupts_Privileged/96 FlexCAN_Ip_ClearBuffStatusFlag/95 FlexCAN_Ip_GetBuffStatusFlag/94 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/93 FlexCAN_Ip_SetTDCOffset_Privileged/92 FlexCAN_Ip_SetTDCOffset_Privileged/92 FlexCAN_Ip_GetBitrateFD/91 FlexCAN_Ip_GetBitrateFD/91 FlexCAN_Ip_SetBitrateCbt_Privileged/90 FlexCAN_Ip_SetBitrateCbt_Privileged/90 FlexCAN_Ip_GetTDCValue/89 FlexCAN_Ip_GetTDCFail/88 FlexCAN_Ip_ClearTDCFail/87 FlexCAN_Ip_GetBitrate/86 FlexCAN_Ip_GetBitrate/86 FlexCAN_Ip_SetBitrate_Privileged/85 FlexCAN_Ip_SetBitrate_Privileged/85 FlexCAN_Ip_SetRxMaskType_Privileged/84 FlexCAN_Ip_SetStopMode_Privileged/83 FlexCAN_Ip_SetStartMode_Privileged/82 FlexCAN_Ip_MainFunctionWrite/79 FlexCAN_Ip_MainFunctionBusOff_Privileged/78 FlexCAN_Ip_MainFunctionRead/77 FlexCAN_Ip_MainFunctionRead/77 FlexCAN_Ip_Deinit_Privileged/76 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/75 FlexCAN_Ip_SetRxIndividualMask_Privileged/74 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/71 FlexCAN_Ip_SendBlocking/70 FlexCAN_Ip_SendBlocking/70 FlexCAN_BusOff_IRQHandler/69 FlexCAN_Error_IRQHandler/68 FlexCAN_Ip_GetControllerRxErrorCounter/67 FlexCAN_Ip_GetControllerTxErrorCounter/66 FlexCAN_Ip_GetErrorStatus/65 FlexCAN_Ip_ClearErrorStatus/64 FlexCAN_IRQHandler/63 FlexCAN_IRQHandler/63 FlexCAN_Ip_RxFifoBlocking/58 FlexCAN_CompleteRxMessageFifoData/62 FlexCAN_Ip_GetTransferStatus/61 FlexCAN_Ip_GetTransferStatus/61 FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_Ip_ConfigRemoteResponseMb/60 FlexCAN_Ip_ConfigRxFifo_Privileged/59 FlexCAN_Ip_RxFifo/57 FlexCAN_Ip_ReceiveBlocking/56 FlexCAN_Ip_Receive/55 FlexCAN_Ip_ConfigRxMb/54 FlexCAN_Ip_ConfigRxMb/54 FlexCAN_Ip_Send/53 FlexCAN_Ip_Send/53 FlexCAN_Ip_Init_Privileged/52 FlexCAN_Ip_Init_Privileged/52 FlexCAN_Ip_Init_Privileged/52 FlexCAN_StartRxMessageFifoData/45 FlexCAN_StartSendData/44 FlexCAN_StartSendData/44 FlexCAN_StartSendData/44 FlexCAN_StartRxMessageBufferData/43 FlexCAN_SetExtendedTimeSegments/12 FlexCAN_SetTimeSegments/11 FlexCAN_SetFDTimeSegments/10 
  Calls: 
FlexCAN_Ip_ManualBusOffRecovery (uint8 Instance)
{
  Flexcan_Ip_StatusType RetVal;
  uint32 uS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * Base;
  Flexcan_Ip_StatusType D.8188;
  long unsigned int D.8185;
  int _1;
  _Bool _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _35;
  Flexcan_Ip_StatusType _38;

  <bb 2> :
  _1 = (int) Instance_18(D);
  Base_20 = Flexcan_Ip_apxBase[_1];
  timeStart = 0;
  timeElapsed_22 = 0;
  uS2Ticks_24 = OsIf_MicrosToTicks (10000, 0);
  RetVal_25 = 1;
  _2 = Instance_18(D) <= 2;
  DevAssert (_2);
  _3 ={v} Base_20->CTRL1;
  _4 = _3 & 64;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  RetVal_27 = 0;
  _5 ={v} Base_20->ESR1;
  _6 = _5 & 32;
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20 ();
  _7 ={v} Base_20->CTRL1;
  _8 = _7 & 4294967231;
  Base_20->CTRL1 ={v} _8;
  _9 ={v} Base_20->CTRL1;
  _10 = _9 | 64;
  Base_20->CTRL1 ={v} _10;
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20 ();
  _11 = OsIf_GetCounter (0);
  timeStart = _11;
  goto <bb 7>; [INV]

  <bb 5> :
  _35 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_36 = _35 + timeElapsed_14;
  if (timeElapsed_36 >= uS2Ticks_24)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  RetVal_37 = 3;
  goto <bb 8>; [INV]

  <bb 7> :
  # timeElapsed_14 = PHI <timeElapsed_22(4), timeElapsed_36(5)>
  _12 ={v} Base_20->ESR1;
  _13 = _12 & 32;
  if (_13 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # RetVal_15 = PHI <RetVal_25(2), RetVal_27(3), RetVal_37(6), RetVal_27(7)>
  _38 = RetVal_15;
  timeStart ={v} {CLOBBER};

  <bb 9> :
<L10>:
  return _38;

}


FlexCAN_Ip_GetListenOnlyMode (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.8179;
  int _1;
  boolean _6;

  <bb 2> :
  _1 = (int) instance_2(D);
  base_4 = Flexcan_Ip_apxBase[_1];
  _6 = FlexCAN_IsListenOnlyModeEnabled (base_4);

  <bb 3> :
<L0>:
  return _6;

}


FlexCAN_Ip_SetListenOnlyMode_Privileged (uint8 instance, const boolean enable)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8173;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _35;

  <bb 2> :
  _1 = instance_15(D) <= 2;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10 ();
  FlexCAN_SetListenOnlyMode (pBase_20, enable_29(D));
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10 ();

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_33 = FlexCAN_Disable (pBase_20);
  if (status_33 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_34 = status_33;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_34(11)>
  _35 = result_11;

  <bb 13> :
<L12>:
  return _35;

}


FlexCAN_Ip_SetRxMb15Mask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8159;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _34;

  <bb 2> :
  _1 = instance_15(D) <= 2;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  freeze_21 = 0;
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_23 = (boolean) _7;
  if (disabled_23 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_25 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_25(3)>
  freeze_27 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_27;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_28 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_28(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  pBase_20->RX15MASK ={v} mask_29(D);

  <bb 9> :
  if (disabled_23 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_32 = FlexCAN_Disable (pBase_20);
  if (status_32 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_33 = status_32;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_33(11)>
  _34 = result_11;

  <bb 13> :
<L12>:
  return _34;

}


FlexCAN_Ip_SetRxMb14Mask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8145;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _34;

  <bb 2> :
  _1 = instance_15(D) <= 2;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  freeze_21 = 0;
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_23 = (boolean) _7;
  if (disabled_23 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_25 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_25(3)>
  freeze_27 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_27;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_28 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_28(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  pBase_20->RX14MASK ={v} mask_29(D);

  <bb 9> :
  if (disabled_23 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_32 = FlexCAN_Disable (pBase_20);
  if (status_32 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_33 = status_32;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_33(11)>
  _34 = result_11;

  <bb 13> :
<L12>:
  return _34;

}


FlexCAN_Ip_AbortTransfer (uint8 u8Instance, uint8 mb_idx)
{
  Flexcan_Ip_StatusType result;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.8131;
  int iftmp.8;
  _Bool _1;
  _Bool _2;
  int _3;
  int _4;
  int _5;
  <unnamed type> _6;
  long unsigned int _7;
  _Bool _8;
  int _9;
  <unnamed type> _10;
  int _11;
  <unnamed type> _12;
  int iftmp.8_15;
  int iftmp.8_22;
  int iftmp.8_23;
  Flexcan_Ip_StatusType _33;

  <bb 2> :
  _1 = u8Instance_18(D) <= 2;
  DevAssert (_1);
  if (mb_idx_21(D) <= 31)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx_21(D) == 255)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.8_23 = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.8_22 = 0;

  <bb 6> :
  # iftmp.8_15 = PHI <iftmp.8_23(4), iftmp.8_22(5)>
  _2 = (_Bool) iftmp.8_15;
  DevAssert (_2);
  _3 = (int) u8Instance_18(D);
  pBase_25 = Flexcan_Ip_apxBase[_3];
  _4 = (int) u8Instance_18(D);
  state_26 = Flexcan_Ip_apxState[_4];
  result_27 = 0;
  if (mb_idx_21(D) <= 31)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 7> :
  _5 = (int) mb_idx_21(D);
  _6 ={v} state_26->mbs[_5].state;
  if (_6 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  result_32 = 5;
  goto <bb 13>; [INV]

  <bb 9> :
  _7 = (long unsigned int) mb_idx_21(D);
  _8 = state_26->isIntActive;
  FLEXCAN_ClearMsgBuffIntCmd (pBase_25, u8Instance_18(D), _7, _8);
  _9 = (int) mb_idx_21(D);
  _10 ={v} state_26->mbs[_9].state;
  if (_10 == 2)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  result_30 = FlexCAN_AbortTxTransfer (u8Instance_18(D), mb_idx_21(D));

  <bb 11> :
  # result_13 = PHI <result_27(9), result_30(10)>
  _11 = (int) mb_idx_21(D);
  _12 ={v} state_26->mbs[_11].state;
  if (_12 == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  FlexCAN_AbortRxTransfer (u8Instance_18(D), mb_idx_21(D));

  <bb 13> :
  # result_14 = PHI <result_27(6), result_32(8), result_13(11), result_13(12)>
  _33 = result_14;

  <bb 14> :
<L13>:
  return _33;

}


FlexCAN_Ip_SetErrorInt_Privileged (uint8 u8Instance, Flexcan_Ip_ErrorIntType type, boolean enable)
{
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8115;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  _Bool _9;
  _Bool _10;
  _Bool _11;
  Flexcan_Ip_StatusType _47;

  <bb 2> :
  _1 = u8Instance_22(D) <= 2;
  DevAssert (_1);
  result_25 = 0;
  status_26 = 0;
  _2 = (int) u8Instance_22(D);
  pBase_27 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_27);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_29 = (boolean) _7;
  if (disabled_29 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_31 = FlexCAN_Enable (pBase_27);

  <bb 4> :
  # result_12 = PHI <result_25(2), result_31(3)>
  if (result_12 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 5> :
  switch (type_32(D)) <default: <L14> [INV], case 0: <L6> [INV], case 1: <L10> [INV], case 2: <L4> [INV], case 3: <L5> [INV], case 4: <L3> [INV]>

  <bb 6> :
<L3>:
  FlexCAN_SetErrIntCmd (pBase_27, 32768, enable_33(D));
  goto <bb 18>; [INV]

  <bb 7> :
<L4>:
  FlexCAN_SetErrIntCmd (pBase_27, 16384, enable_33(D));
  goto <bb 18>; [INV]

  <bb 8> :
<L5>:
  FlexCAN_SetErrIntCmd (pBase_27, 16385, enable_33(D));
  goto <bb 18>; [INV]

  <bb 9> :
<L6>:
  _8 = FlexCAN_IsFreezeMode (pBase_27);
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  result_42 = 1;
  goto <bb 12>; [INV]

  <bb 11> :
  FlexCAN_SetErrIntCmd (pBase_27, 1024, enable_33(D));

  <bb 12> :
  # result_13 = PHI <result_42(10), result_12(11)>
  goto <bb 18>; [INV]

  <bb 13> :
<L10>:
  _10 = FlexCAN_IsFreezeMode (pBase_27);
  _11 = ~_10;
  if (_11 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result_39 = 1;
  goto <bb 16>; [INV]

  <bb 15> :
  FlexCAN_SetErrIntCmd (pBase_27, 2048, enable_33(D));

  <bb 16> :
  # result_14 = PHI <result_39(14), result_12(15)>
  goto <bb 18>; [INV]

  <bb 17> :
<L14>:
  DevAssert (0);

  <bb 18> :
  # result_15 = PHI <result_12(4), result_12(6), result_12(7), result_12(8), result_13(12), result_14(16), result_12(17)>
  if (disabled_29 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  status_45 = FlexCAN_Disable (pBase_27);
  if (status_45 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  result_46 = status_45;

  <bb 21> :
  # result_16 = PHI <result_15(18), result_15(19), result_46(20)>
  _47 = result_16;

  <bb 22> :
<L21>:
  return _47;

}


FlexCAN_Ip_DisableInterrupts_Privileged (uint8 u8Instance)
{
  struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.8099;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  Flexcan_Ip_StatusType _17;

  <bb 2> :
  _1 = (int) u8Instance_7(D);
  pBase_9 = Flexcan_Ip_apxBase[_1];
  result_10 = 1;
  _2 = (int) u8Instance_7(D);
  state_11 = Flexcan_Ip_apxState[_2];
  _3 = u8Instance_7(D) <= 2;
  DevAssert (_3);
  _4 = FlexCAN_IsEnabled (pBase_9);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_DisableInterrupts (pBase_9);
  state_11->isIntActive = 0;
  result_16 = 0;

  <bb 4> :
  # result_5 = PHI <result_10(2), result_16(3)>
  _17 = result_5;

  <bb 5> :
<L2>:
  return _17;

}


FlexCAN_Ip_EnableInterrupts_Privileged (uint8 u8Instance)
{
  struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.8095;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  Flexcan_Ip_StatusType _17;

  <bb 2> :
  _1 = (int) u8Instance_7(D);
  pBase_9 = Flexcan_Ip_apxBase[_1];
  result_10 = 1;
  _2 = (int) u8Instance_7(D);
  state_11 = Flexcan_Ip_apxState[_2];
  _3 = u8Instance_7(D) <= 2;
  DevAssert (_3);
  _4 = FlexCAN_IsEnabled (pBase_9);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_EnableInterrupts (pBase_9, u8Instance_7(D));
  state_11->isIntActive = 1;
  result_16 = 0;

  <bb 4> :
  # result_5 = PHI <result_10(2), result_16(3)>
  _17 = result_5;

  <bb 5> :
<L2>:
  return _17;

}


FlexCAN_Ip_ClearBuffStatusFlag (uint8 instance, uint8 msgBuffIdx)
{
  struct FLEXCAN_Type * pBase;
  _Bool _1;
  int _2;
  long unsigned int _3;

  <bb 2> :
  _1 = instance_4(D) <= 2;
  DevAssert (_1);
  _2 = (int) instance_4(D);
  pBase_7 = Flexcan_Ip_apxBase[_2];
  _3 = (long unsigned int) msgBuffIdx_8(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_7, _3);
  return;

}


FlexCAN_Ip_GetBuffStatusFlag (uint8 instance, uint8 msgBuffIdx)
{
  const struct FLEXCAN_Type * pBase;
  boolean returnResult;
  boolean D.8091;
  _Bool _1;
  int _2;
  long unsigned int _3;
  unsigned char _4;
  boolean _13;

  <bb 2> :
  returnResult_5 = 1;
  _1 = instance_6(D) <= 2;
  DevAssert (_1);
  _2 = (int) instance_6(D);
  pBase_9 = Flexcan_Ip_apxBase[_2];
  _3 = (long unsigned int) msgBuffIdx_10(D);
  _4 = FlexCAN_GetBuffStatusFlag (pBase_9, _3);
  returnResult_12 = _4 == 1;
  _13 = returnResult_12;

  <bb 3> :
<L0>:
  return _13;

}


FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged (uint8 instance, uint8 value)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8089;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _35;

  <bb 2> :
  _1 = instance_15(D) <= 2;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17 ();
  FlexCAN_SetTxArbitrationStartDelay (pBase_20, value_29(D));
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17 ();

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_33 = FlexCAN_Disable (pBase_20);
  if (status_33 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_34 = status_33;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_34(11)>
  _35 = result_11;

  <bb 13> :
<L12>:
  return _35;

}


FlexCAN_Ip_SetTDCOffset_Privileged (uint8 instance, boolean enable, uint8 offset)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8073;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  _Bool _9;
  _Bool _10;
  Flexcan_Ip_StatusType _40;

  <bb 2> :
  _1 = instance_17(D) <= 2;
  DevAssert (_1);
  result_20 = 0;
  status_21 = 0;
  _2 = (int) instance_17(D);
  pBase_22 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_22);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_24 = (boolean) _7;
  if (disabled_24 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_26 = FlexCAN_Enable (pBase_22);

  <bb 4> :
  # result_11 = PHI <result_20(2), result_26(3)>
  _8 = FlexCAN_IsFDAvailable (pBase_22);
  _9 = _8;
  DevAssert (_9);
  freeze_30 = FlexCAN_IsFreezeMode (pBase_22);
  _10 = ~freeze_30;
  if (_10 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_11 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_31 = 1;

  <bb 7> :
  # result_12 = PHI <result_11(4), result_11(5), result_31(6)>
  if (result_12 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16 ();
  FlexCAN_SetTDCOffset (pBase_22, enable_33(D), offset_34(D));
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16 ();

  <bb 9> :
  if (disabled_24 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_38 = FlexCAN_Disable (pBase_22);
  if (status_38 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_39 = status_38;

  <bb 12> :
  # result_13 = PHI <result_12(9), result_12(10), result_39(11)>
  _40 = result_13;

  <bb 13> :
<L12>:
  return _40;

}


FlexCAN_Ip_GetBitrateFD (uint8 instance, struct Flexcan_Ip_TimeSegmentType * bitrate)
{
  boolean enhCbt;
  const struct FLEXCAN_Type * pBase;
  boolean D.8059;
  _Bool _1;
  _Bool _2;
  int _3;
  boolean _12;

  <bb 2> :
  _1 = instance_4(D) <= 2;
  DevAssert (_1);
  _2 = bitrate_7(D) != 0B;
  DevAssert (_2);
  _3 = (int) instance_4(D);
  pBase_9 = Flexcan_Ip_apxBase[_3];
  enhCbt_10 = 0;
  FlexCAN_GetFDTimeSegments (pBase_9, bitrate_7(D));
  _12 = enhCbt_10;

  <bb 3> :
<L0>:
  return _12;

}


FlexCAN_Ip_SetBitrateCbt_Privileged (uint8 instance, const struct Flexcan_Ip_TimeSegmentType * bitrate, boolean bitRateSwitch)
{
  boolean freeze;
  boolean fd_enable;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8055;
  _Bool _1;
  _Bool _2;
  int _3;
  _Bool _4;
  int _5;
  _Bool _6;
  _Bool _7;
  int _8;
  _Bool _9;
  _Bool _10;
  Flexcan_Ip_StatusType _42;

  <bb 2> :
  _1 = instance_17(D) <= 2;
  DevAssert (_1);
  _2 = bitrate_20(D) != 0B;
  DevAssert (_2);
  result_22 = 0;
  status_23 = 0;
  _3 = (int) instance_17(D);
  pBase_24 = Flexcan_Ip_apxBase[_3];
  _4 = FlexCAN_IsEnabled (pBase_24);
  _5 = (int) _4;
  _6 = _5 != 0;
  _7 = ~_6;
  _8 = (int) _7;
  disabled_26 = (boolean) _8;
  fd_enable_28 = FlexCAN_IsFDEnabled (pBase_24);
  if (disabled_26 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_30 = FlexCAN_Enable (pBase_24);

  <bb 4> :
  # result_11 = PHI <result_22(2), result_30(3)>
  freeze_32 = FlexCAN_IsFreezeMode (pBase_24);
  _9 = ~fd_enable_28;
  if (_9 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _10 = ~freeze_32;
  if (_10 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (result_11 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  result_33 = 1;

  <bb 8> :
  # result_12 = PHI <result_11(5), result_11(6), result_33(7)>
  if (result_12 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15 ();
  FlexCAN_SetFDEnabled (pBase_24, fd_enable_28, bitRateSwitch_35(D));
  FlexCAN_SetFDTimeSegments (pBase_24, bitrate_20(D));
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15 ();

  <bb 10> :
  if (disabled_26 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 11> :
  status_40 = FlexCAN_Disable (pBase_24);
  if (status_40 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  result_41 = status_40;

  <bb 13> :
  # result_13 = PHI <result_12(10), result_12(11), result_41(12)>
  _42 = result_13;

  <bb 14> :
<L12>:
  return _42;

}


FlexCAN_Ip_GetTDCValue (uint8 u8Instance)
{
  const struct FLEXCAN_Type * pBase;
  uint8 value;
  uint8 D.8041;
  _Bool _1;
  int _2;
  long unsigned int _3;
  unsigned char _4;
  uint8 _11;

  <bb 2> :
  value_5 = 0;
  _1 = u8Instance_6(D) <= 2;
  DevAssert (_1);
  _2 = (int) u8Instance_6(D);
  pBase_9 = Flexcan_Ip_apxBase[_2];
  _3 ={v} pBase_9->FDCTRL;
  _4 = (unsigned char) _3;
  value_10 = _4 & 63;
  _11 = value_10;

  <bb 3> :
<L0>:
  return _11;

}


FlexCAN_Ip_GetTDCFail (uint8 u8Instance)
{
  const struct FLEXCAN_Type * pBase;
  boolean value;
  boolean D.8039;
  _Bool _1;
  int _2;
  long unsigned int _3;
  long unsigned int _4;
  boolean _11;

  <bb 2> :
  value_5 = 0;
  _1 = u8Instance_6(D) <= 2;
  DevAssert (_1);
  _2 = (int) u8Instance_6(D);
  pBase_9 = Flexcan_Ip_apxBase[_2];
  _3 ={v} pBase_9->FDCTRL;
  _4 = _3 & 16384;
  value_10 = _4 == 16384;
  _11 = value_10;

  <bb 3> :
<L0>:
  return _11;

}


FlexCAN_Ip_ClearTDCFail (uint8 u8Instance)
{
  struct FLEXCAN_Type * pBase;
  _Bool _1;
  int _2;
  long unsigned int _3;
  long unsigned int _4;

  <bb 2> :
  _1 = u8Instance_5(D) <= 2;
  DevAssert (_1);
  _2 = (int) u8Instance_5(D);
  pBase_8 = Flexcan_Ip_apxBase[_2];
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09 ();
  _3 ={v} pBase_8->FDCTRL;
  _4 = _3 | 16384;
  pBase_8->FDCTRL ={v} _4;
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09 ();
  return;

}


FlexCAN_Ip_GetBitrate (uint8 instance, struct Flexcan_Ip_TimeSegmentType * bitrate)
{
  boolean enhCbt;
  const struct FLEXCAN_Type * pBase;
  boolean D.8037;
  _Bool _1;
  _Bool _2;
  int _3;
  _Bool _4;
  boolean _16;

  <bb 2> :
  _1 = instance_6(D) <= 2;
  DevAssert (_1);
  _2 = bitrate_9(D) != 0B;
  DevAssert (_2);
  _3 = (int) instance_6(D);
  pBase_11 = Flexcan_Ip_apxBase[_3];
  enhCbt_12 = 0;
  _4 = FlexCAN_IsExCbtEnabled (pBase_11);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_GetExtendedTimeSegments (pBase_11, bitrate_9(D));
  goto <bb 5>; [INV]

  <bb 4> :
  FlexCAN_GetTimeSegments (pBase_11, bitrate_9(D));

  <bb 5> :
  _16 = enhCbt_12;

  <bb 6> :
<L3>:
  return _16;

}


FlexCAN_Ip_SetBitrate_Privileged (uint8 instance, const struct Flexcan_Ip_TimeSegmentType * bitrate, boolean enhExt)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8030;
  _Bool _1;
  _Bool _2;
  int _3;
  _Bool _4;
  int _5;
  _Bool _6;
  _Bool _7;
  int _8;
  _Bool _9;
  _Bool _10;
  Flexcan_Ip_StatusType _41;

  <bb 2> :
  _1 = instance_18(D) <= 2;
  DevAssert (_1);
  _2 = bitrate_21(D) != 0B;
  DevAssert (_2);
  result_23 = 0;
  status_24 = 0;
  _3 = (int) instance_18(D);
  pBase_25 = Flexcan_Ip_apxBase[_3];
  _4 = FlexCAN_IsEnabled (pBase_25);
  _5 = (int) _4;
  _6 = _5 != 0;
  _7 = ~_6;
  _8 = (int) _7;
  disabled_27 = (boolean) _8;
  if (disabled_27 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_29 = FlexCAN_Enable (pBase_25);

  <bb 4> :
  # result_11 = PHI <result_23(2), result_29(3)>
  freeze_31 = FlexCAN_IsFreezeMode (pBase_25);
  _9 = ~freeze_31;
  if (_9 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_11 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_32 = 1;

  <bb 7> :
  # result_12 = PHI <result_11(4), result_11(5), result_32(6)>
  if (result_12 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14 ();
  _10 = FlexCAN_IsExCbtEnabled (pBase_25);
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  FlexCAN_SetExtendedTimeSegments (pBase_25, bitrate_21(D));
  goto <bb 11>; [INV]

  <bb 10> :
  FlexCAN_SetTimeSegments (pBase_25, bitrate_21(D));

  <bb 11> :
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14 ();

  <bb 12> :
  if (disabled_27 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  status_39 = FlexCAN_Disable (pBase_25);
  if (status_39 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result_40 = status_39;

  <bb 15> :
  # result_13 = PHI <result_12(12), result_12(13), result_40(14)>
  _41 = result_13;

  <bb 16> :
<L15>:
  return _41;

}


FlexCAN_Ip_SetRxMaskType_Privileged (uint8 instance, Flexcan_Ip_RxMaskType type)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8010;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _35;

  <bb 2> :
  _1 = instance_15(D) <= 2;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08 ();
  FlexCAN_SetRxMaskType (pBase_20, type_29(D));
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08 ();

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_33 = FlexCAN_Disable (pBase_20);
  if (status_33 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_34 = status_33;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_34(11)>
  _35 = result_11;

  <bb 13> :
<L12>:
  return _35;

}


FlexCAN_Ip_SetStopMode_Privileged (uint8 instance)
{
  Flexcan_Ip_StatusType status;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.7996;
  _Bool _1;
  int _2;
  Flexcan_Ip_StatusType _13;

  <bb 2> :
  _1 = instance_5(D) <= 2;
  DevAssert (_1);
  _2 = (int) instance_5(D);
  pBase_8 = Flexcan_Ip_apxBase[_2];
  status_10 = FlexCAN_EnterFreezeMode (pBase_8);
  if (status_10 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  status_12 = FlexCAN_Disable (pBase_8);

  <bb 4> :
  # status_3 = PHI <status_10(2), status_12(3)>
  _13 = status_3;

  <bb 5> :
<L2>:
  return _13;

}


FlexCAN_Ip_SetStartMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.7992;
  _Bool _1;
  int _2;
  long unsigned int _3;
  long unsigned int _4;
  Flexcan_Ip_StatusType _13;

  <bb 2> :
  _1 = instance_5(D) <= 2;
  DevAssert (_1);
  _2 = (int) instance_5(D);
  pBase_8 = Flexcan_Ip_apxBase[_2];
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07 ();
  _3 ={v} pBase_8->MCR;
  _4 = _3 & 2147483647;
  pBase_8->MCR ={v} _4;
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07 ();
  _13 = FlexCAN_ExitFreezeMode (pBase_8);

  <bb 3> :
<L0>:
  return _13;

}


FlexCAN_Ip_GetStartMode_Privileged (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.7990;
  int _1;
  long unsigned int _2;
  long unsigned int _3;
  boolean _7;

  <bb 2> :
  _1 = (int) instance_4(D);
  base_6 = Flexcan_Ip_apxBase[_1];
  _2 ={v} base_6->MCR;
  _3 = _2 & 17825792;
  _7 = _3 == 0;

  <bb 3> :
<L0>:
  return _7;

}


FlexCAN_Ip_GetStopMode_Privileged (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.7988;
  int _1;
  long unsigned int _2;
  long unsigned int _3;
  boolean _7;

  <bb 2> :
  _1 = (int) instance_4(D);
  base_6 = Flexcan_Ip_apxBase[_1];
  _2 ={v} base_6->MCR;
  _3 = _2 & 1048576;
  _7 = _3 == 1048576;

  <bb 3> :
<L0>:
  return _7;

}


FlexCAN_Ip_MainFunctionWrite (uint8 instance, uint8 mb_idx)
{
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  unsigned char _5;
  long unsigned int _6;
  int _7;
  long unsigned int _8;
  long unsigned int _9;
  int _10;

  <bb 2> :
  _1 = (int) instance_12(D);
  base_14 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_12(D);
  state_15 = Flexcan_Ip_apxState[_2];
  _3 = instance_12(D) <= 2;
  DevAssert (_3);
  _4 = (long unsigned int) mb_idx_17(D);
  _5 = FlexCAN_GetBuffStatusFlag (base_14, _4);
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _6 = (long unsigned int) mb_idx_17(D);
  _7 = (int) mb_idx_17(D);
  _8 = FlexCAN_GetMsgBuffTimestamp (base_14, _6);
  state_15->mbs[_7].time_stamp = _8;
  FlexCAN_UnlockRxMsgBuff (base_14);
  _9 = (long unsigned int) mb_idx_17(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_14, _9);
  _10 = (int) mb_idx_17(D);
  state_15->mbs[_10].state ={v} 0;

  <bb 4> :
  return;

}


FlexCAN_Ip_MainFunctionBusOff_Privileged (uint8 instance)
{
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType eRetVal;
  Flexcan_Ip_StatusType D.7984;
  int _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _5;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _6;
  Flexcan_Ip_StatusType _21;

  <bb 2> :
  eRetVal_10 = 1;
  _1 = (int) instance_11(D);
  base_13 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_11(D);
  state_14 = Flexcan_Ip_apxState[_2];
  u32ErrStatus_15 = 0;
  _3 = instance_11(D) <= 2;
  DevAssert (_3);
  u32ErrStatus_17 ={v} base_13->ESR1;
  _4 = u32ErrStatus_17 & 4;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _5 = state_14->error_callback;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = state_14->error_callback;
  _6 (instance_11(D), 7, u32ErrStatus_17, state_14);

  <bb 5> :
  base_13->ESR1 ={v} 4;
  eRetVal_20 = 0;

  <bb 6> :
  # eRetVal_7 = PHI <eRetVal_10(2), eRetVal_20(5)>
  _21 = eRetVal_7;

  <bb 7> :
<L4>:
  return _21;

}


FlexCAN_Ip_MainFunctionRead (uint8 instance, uint8 mb_idx)
{
  const struct Flexcan_Ip_StateType * state;
  const struct FLEXCAN_Type * base;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  unsigned char _6;
  long unsigned int _7;
  unsigned char _8;
  int _9;
  <unnamed type> _10;
  long unsigned int _11;

  <bb 2> :
  _1 = (int) instance_14(D);
  base_16 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_14(D);
  state_17 = Flexcan_Ip_apxState[_2];
  _3 = instance_14(D) <= 2;
  DevAssert (_3);
  _4 = mb_idx_19(D) <= 31;
  DevAssert (_4);
  _5 = state_17->bIsLegacyFifoEn;
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  if (mb_idx_19(D) <= 7)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  if (mb_idx_19(D) == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _6 = FlexCAN_GetBuffStatusFlag (base_16, 5);
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_IRQHandlerRxFIFO (instance_14(D), 5);

  <bb 7> :
  goto <bb 11>; [INV]

  <bb 8> :
  _7 = (long unsigned int) mb_idx_19(D);
  _8 = FlexCAN_GetBuffStatusFlag (base_16, _7);
  if (_8 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _9 = (int) mb_idx_19(D);
  _10 ={v} state_17->mbs[_9].state;
  if (_10 == 1)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _11 = (long unsigned int) mb_idx_19(D);
  FlexCAN_IRQHandlerRxMB (instance_14(D), _11);

  <bb 11> :
  return;

}


FlexCAN_Ip_Deinit_Privileged (uint8 instance)
{
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.7964;
  int _1;
  _Bool _2;
  int _3;
  Flexcan_Ip_StatusType _15;

  <bb 2> :
  _1 = (int) instance_5(D);
  base_7 = Flexcan_Ip_apxBase[_1];
  result_8 = 1;
  _2 = instance_5(D) <= 2;
  DevAssert (_2);
  result_11 = FlexCAN_EnterFreezeMode (base_7);
  if (result_11 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_SetRegDefaultVal (base_7);
  FlexCAN_Disable (base_7);
  _3 = (int) instance_5(D);
  Flexcan_Ip_apxState[_3] = 0B;

  <bb 4> :
  _15 = result_11;

  <bb 5> :
<L2>:
  return _15;

}


FlexCAN_Ip_SetRxFifoGlobalMask_Privileged (uint8 instance, uint32 mask)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7960;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _33;

  <bb 2> :
  _1 = instance_15(D) <= 2;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetRxFifoGlobalMask (pBase_20, mask_28(D));

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_31 = FlexCAN_Disable (pBase_20);
  if (status_31 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_32 = status_31;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_32(11)>
  _33 = result_11;

  <bb 13> :
<L12>:
  return _33;

}


FlexCAN_Ip_SetRxIndividualMask_Privileged (uint8 instance, uint8 mb_idx, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7946;
  int _1;
  _Bool _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  _Bool _6;
  int _7;
  _Bool _8;
  _Bool _9;
  int _10;
  _Bool _11;
  long unsigned int _12;
  Flexcan_Ip_StatusType _40;

  <bb 2> :
  result_19 = 0;
  status_20 = 0;
  _1 = (int) instance_21(D);
  pBase_23 = Flexcan_Ip_apxBase[_1];
  freeze_24 = 0;
  _2 = instance_21(D) <= 2;
  DevAssert (_2);
  _3 = (long unsigned int) mb_idx_26(D);
  _4 ={v} pBase_23->MCR;
  _5 = _4 & 127;
  if (_3 > _5)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx_26(D) > 31)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  result_39 = 4;
  goto <bb 15>; [INV]

  <bb 5> :
  _6 = FlexCAN_IsEnabled (pBase_23);
  _7 = (int) _6;
  _8 = _7 != 0;
  _9 = ~_8;
  _10 = (int) _9;
  disabled_28 = (boolean) _10;
  if (disabled_28 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_30 = FlexCAN_Enable (pBase_23);

  <bb 7> :
  # result_13 = PHI <result_19(5), result_30(6)>
  freeze_32 = FlexCAN_IsFreezeMode (pBase_23);
  _11 = ~freeze_32;
  if (_11 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  if (result_13 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  result_33 = 1;

  <bb 10> :
  # result_14 = PHI <result_13(7), result_13(8), result_33(9)>
  if (result_14 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _12 = (long unsigned int) mb_idx_26(D);
  FlexCAN_SetRxIndividualMask (pBase_23, _12, mask_34(D));

  <bb 12> :
  if (disabled_28 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  status_37 = FlexCAN_Disable (pBase_23);
  if (status_37 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result_38 = status_37;

  <bb 15> :
  # result_15 = PHI <result_39(4), result_14(12), result_14(13), result_38(14)>
  _40 = result_15;

  <bb 16> :
<L16>:
  return _40;

}


FlexCAN_Ip_ExitFreezeMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.7928;
  int _1;
  Flexcan_Ip_StatusType _6;

  <bb 2> :
  _1 = (int) instance_2(D);
  base_4 = Flexcan_Ip_apxBase[_1];
  _6 = FlexCAN_ExitFreezeMode (base_4);

  <bb 3> :
<L0>:
  return _6;

}


FlexCAN_Ip_EnterFreezeMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.7926;
  int _1;
  Flexcan_Ip_StatusType _6;

  <bb 2> :
  _1 = (int) instance_2(D);
  base_4 = Flexcan_Ip_apxBase[_1];
  _6 = FlexCAN_EnterFreezeMode (base_4);

  <bb 3> :
<L0>:
  return _6;

}


FlexCAN_Ip_SetRxMbGlobalMask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7924;
  int _1;
  _Bool _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _34;

  <bb 2> :
  result_15 = 0;
  status_16 = 0;
  _1 = (int) instance_17(D);
  pBase_19 = Flexcan_Ip_apxBase[_1];
  freeze_20 = 0;
  _2 = instance_17(D) <= 2;
  DevAssert (_2);
  _3 = FlexCAN_IsEnabled (pBase_19);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_23 = (boolean) _7;
  if (disabled_23 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_25 = FlexCAN_Enable (pBase_19);

  <bb 4> :
  # result_9 = PHI <result_15(2), result_25(3)>
  freeze_27 = FlexCAN_IsFreezeMode (pBase_19);
  _8 = ~freeze_27;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_28 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_28(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetRxMsgBuffGlobalMask (pBase_19, mask_29(D));

  <bb 9> :
  if (disabled_23 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_32 = FlexCAN_Disable (pBase_19);
  if (status_32 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_33 = status_32;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_33(11)>
  _34 = result_11;

  <bb 13> :
<L12>:
  return _34;

}


FlexCAN_Ip_SendBlocking (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data, uint32 timeout_ms)
{
  volatile uint32 * flexcan_mb;
  uint32 flexcan_mb_config;
  uint32 uS2Ticks;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7909;
  long unsigned int D.7902;
  long unsigned int D.7895;
  int _1;
  int _2;
  long unsigned int _3;
  _Bool _4;
  _Bool _5;
  long unsigned int _6;
  long unsigned int _7;
  unsigned char _8;
  int _9;
  <unnamed type> _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  unsigned char _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  int _21;
  long unsigned int _59;
  long unsigned int _76;
  Flexcan_Ip_StatusType _84;

  <bb 2> :
  _1 = (int) instance_35(D);
  base_37 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_35(D);
  state_38 = Flexcan_Ip_apxState[_2];
  timeStart = 0;
  timeElapsed_40 = 0;
  _3 = timeout_ms_41(D) * 1000;
  mS2Ticks_43 = OsIf_MicrosToTicks (_3, 0);
  uS2Ticks_44 = 0;
  flexcan_mb_config_45 = 0;
  flexcan_mb_46 = 0B;
  _4 = instance_35(D) <= 2;
  DevAssert (_4);
  _5 = tx_info_48(D) != 0B;
  DevAssert (_5);
  result_54 = FlexCAN_StartSendData (instance_35(D), mb_idx_50(D), tx_info_48(D), msg_id_51(D), mb_data_52(D));
  if (result_54 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 3> :
  _6 = OsIf_GetCounter (0);
  timeStart = _6;
  goto <bb 6>; [INV]

  <bb 4> :
  _59 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_60 = _59 + timeElapsed_27;
  if (timeElapsed_60 >= mS2Ticks_43)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  result_61 = 3;
  goto <bb 7>; [INV]

  <bb 6> :
  # timeElapsed_27 = PHI <timeElapsed_40(3), timeElapsed_60(4)>
  _7 = (long unsigned int) mb_idx_50(D);
  _8 = FlexCAN_GetBuffStatusFlag (base_37, _7);
  if (_8 != 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  # result_22 = PHI <result_61(5), result_54(6)>
  if (result_22 == 3)
    goto <bb 8>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 8> :
  _9 = (int) mb_idx_50(D);
  _10 ={v} state_38->mbs[_9].state;
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 9> :
  _11 = (long unsigned int) mb_idx_50(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_37, _11);
  _12 = (long unsigned int) mb_idx_50(D);
  flexcan_mb_64 = FlexCAN_GetMsgBuffRegion (base_37, _12);
  flexcan_mb_config_65 ={v} *flexcan_mb_64;
  flexcan_mb_config_66 = flexcan_mb_config_65 & 4043309055;
  flexcan_mb_config_67 = flexcan_mb_config_66 | 150994944;
  *flexcan_mb_64 ={v} flexcan_mb_config_67;
  uS2Ticks_70 = OsIf_MicrosToTicks (10000, 0);
  _13 = OsIf_GetCounter (0);
  timeStart = _13;
  timeElapsed_73 = 0;
  goto <bb 12>; [INV]

  <bb 10> :
  _76 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_77 = _76 + timeElapsed_28;
  if (timeElapsed_77 >= uS2Ticks_70)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_78 = 3;
  goto <bb 13>; [INV]

  <bb 12> :
  # timeElapsed_28 = PHI <timeElapsed_73(9), timeElapsed_77(10)>
  _14 = (long unsigned int) mb_idx_50(D);
  _15 = FlexCAN_GetBuffStatusFlag (base_37, _14);
  if (_15 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # result_23 = PHI <result_78(11), result_22(12)>
  flexcan_mb_config_79 ={v} *flexcan_mb_64;
  _16 = flexcan_mb_config_79 >> 24;
  _17 = _16 & 15;
  if (_17 == 8)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result_80 = 0;

  <bb 15> :
  # result_24 = PHI <result_23(13), result_80(14)>
  _18 = flexcan_mb_config_79 >> 24;
  _19 = _18 & 15;
  if (_19 == 9)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  result_81 = 3;

  <bb 17> :
  # result_25 = PHI <result_22(7), result_22(8), result_24(15), result_81(16)>
  _20 = (long unsigned int) mb_idx_50(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_37, _20);
  _21 = (int) mb_idx_50(D);
  state_38->mbs[_21].state ={v} 0;

  <bb 18> :
  # result_26 = PHI <result_54(2), result_25(17)>
  _84 = result_26;
  timeStart ={v} {CLOBBER};

  <bb 19> :
<L21>:
  return _84;

}


FlexCAN_BusOff_IRQHandler (uint8 instance)
{
  boolean isSpuriousInt;
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _7;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _12;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _17;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _18;

  <bb 2> :
  _1 = (int) instance_33(D);
  base_35 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_33(D);
  state_36 = Flexcan_Ip_apxState[_2];
  u32ErrStatus_37 = 0;
  isSpuriousInt_38 = 1;
  _3 = instance_33(D) <= 2;
  DevAssert (_3);
  if (state_36 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 3> :
  u32ErrStatus_40 ={v} base_35->ESR1;
  _4 = u32ErrStatus_40 & 131072;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _5 ={v} base_35->CTRL1;
  _6 = _5 & 2048;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  base_35->ESR1 ={v} 131072;
  _7 = state_36->error_callback;
  if (_7 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _8 = state_36->error_callback;
  _8 (instance_33(D), 9, u32ErrStatus_40, state_36);
  u32ErrStatus_43 ={v} base_35->ESR1;

  <bb 7> :
  # u32ErrStatus_19 = PHI <u32ErrStatus_40(5), u32ErrStatus_43(6)>
  isSpuriousInt_44 = 0;

  <bb 8> :
  # u32ErrStatus_20 = PHI <u32ErrStatus_40(3), u32ErrStatus_40(4), u32ErrStatus_19(7)>
  # isSpuriousInt_23 = PHI <isSpuriousInt_38(3), isSpuriousInt_38(4), isSpuriousInt_44(7)>
  _9 = u32ErrStatus_20 & 65536;
  if (_9 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  _10 ={v} base_35->CTRL1;
  _11 = _10 & 1024;
  if (_11 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  base_35->ESR1 ={v} 65536;
  _12 = state_36->error_callback;
  if (_12 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _13 = state_36->error_callback;
  _13 (instance_33(D), 8, u32ErrStatus_20, state_36);
  u32ErrStatus_47 ={v} base_35->ESR1;

  <bb 12> :
  # u32ErrStatus_21 = PHI <u32ErrStatus_20(10), u32ErrStatus_47(11)>
  isSpuriousInt_48 = 0;

  <bb 13> :
  # u32ErrStatus_22 = PHI <u32ErrStatus_20(8), u32ErrStatus_20(9), u32ErrStatus_21(12)>
  # isSpuriousInt_24 = PHI <isSpuriousInt_23(8), isSpuriousInt_23(9), isSpuriousInt_48(12)>
  _14 = u32ErrStatus_22 & 4;
  if (_14 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 14> :
  _15 ={v} base_35->CTRL1;
  _16 = _15 & 32768;
  if (_16 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  base_35->ESR1 ={v} 4;
  _17 = state_36->error_callback;
  if (_17 != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _18 = state_36->error_callback;
  _18 (instance_33(D), 7, u32ErrStatus_22, state_36);

  <bb 17> :
  isSpuriousInt_51 = 0;

  <bb 18> :
  # isSpuriousInt_25 = PHI <isSpuriousInt_38(2), isSpuriousInt_24(13), isSpuriousInt_24(14), isSpuriousInt_51(17)>
  if (isSpuriousInt_25 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  base_35->ESR1 ={v} 720900;

  <bb 20> :
  return;

}


FlexCAN_Error_IRQHandler (uint8 instance)
{
  boolean isSpuriousInt;
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  int _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _7;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _8;
  long unsigned int _9;
  long unsigned int _10;
  signed int _11;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _12;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _13;

  <bb 2> :
  _1 = (int) instance_23(D);
  pBase_25 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_23(D);
  state_26 = Flexcan_Ip_apxState[_2];
  u32ErrStatus_27 = 0;
  isSpuriousInt_28 = 1;
  _3 = instance_23(D) <= 2;
  DevAssert (_3);
  if (state_26 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 3> :
  u32ErrStatus_30 ={v} pBase_25->ESR1;
  _4 = u32ErrStatus_30 & 2;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _5 ={v} pBase_25->CTRL1;
  _6 = _5 & 16384;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  pBase_25->ESR1 ={v} 2;
  _7 = state_26->error_callback;
  if (_7 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _8 = state_26->error_callback;
  _8 (instance_23(D), 5, u32ErrStatus_30, state_26);
  u32ErrStatus_33 ={v} pBase_25->ESR1;

  <bb 7> :
  # u32ErrStatus_14 = PHI <u32ErrStatus_30(5), u32ErrStatus_33(6)>
  isSpuriousInt_34 = 0;

  <bb 8> :
  # u32ErrStatus_15 = PHI <u32ErrStatus_30(3), u32ErrStatus_30(4), u32ErrStatus_14(7)>
  # isSpuriousInt_16 = PHI <isSpuriousInt_28(3), isSpuriousInt_28(4), isSpuriousInt_34(7)>
  _9 = u32ErrStatus_15 & 1048576;
  if (_9 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  _10 ={v} pBase_25->CTRL2;
  _11 = (signed int) _10;
  if (_11 < 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  pBase_25->ESR1 ={v} 1048576;
  _12 = state_26->error_callback;
  if (_12 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _13 = state_26->error_callback;
  _13 (instance_23(D), 6, u32ErrStatus_15, state_26);

  <bb 12> :
  isSpuriousInt_37 = 0;

  <bb 13> :
  # isSpuriousInt_17 = PHI <isSpuriousInt_28(2), isSpuriousInt_16(8), isSpuriousInt_16(9), isSpuriousInt_37(12)>
  if (isSpuriousInt_17 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  pBase_25->ESR1 ={v} 3145730;

  <bb 15> :
  return;

}


FlexCAN_Ip_GetControllerRxErrorCounter (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint8 D.7853;
  int _1;
  _Bool _2;
  long unsigned int _3;
  long unsigned int _4;
  uint8 _9;

  <bb 2> :
  _1 = (int) instance_5(D);
  base_7 = Flexcan_Ip_apxBase[_1];
  _2 = instance_5(D) <= 2;
  DevAssert (_2);
  _3 ={v} base_7->ECR;
  _4 = _3 >> 8;
  _9 = (uint8) _4;

  <bb 3> :
<L0>:
  return _9;

}


FlexCAN_Ip_GetControllerTxErrorCounter (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint8 D.7851;
  int _1;
  _Bool _2;
  long unsigned int _3;
  uint8 _8;

  <bb 2> :
  _1 = (int) instance_4(D);
  base_6 = Flexcan_Ip_apxBase[_1];
  _2 = instance_4(D) <= 2;
  DevAssert (_2);
  _3 ={v} base_6->ECR;
  _8 = (uint8) _3;

  <bb 3> :
<L0>:
  return _8;

}


FlexCAN_Ip_GetErrorStatus (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint32 D.7849;
  int _1;
  _Bool _2;
  uint32 _7;

  <bb 2> :
  _1 = (int) instance_3(D);
  base_5 = Flexcan_Ip_apxBase[_1];
  _2 = instance_3(D) <= 2;
  DevAssert (_2);
  _7 ={v} base_5->ESR1;

  <bb 3> :
<L0>:
  return _7;

}


FlexCAN_Ip_ClearErrorStatus (uint8 instance, uint32 error)
{
  struct FLEXCAN_Type * base;
  int _1;
  _Bool _2;

  <bb 2> :
  _1 = (int) instance_3(D);
  base_5 = Flexcan_Ip_apxBase[_1];
  _2 = instance_3(D) <= 2;
  DevAssert (_2);
  base_5->ESR1 ={v} error_7(D);
  return;

}


FlexCAN_IRQHandler (uint8 instance, uint32 startMbIdx, uint32 endMbIdx)
{
  uint32 mb_idx;
  boolean bIsSpuriousInt;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  uint32 flag_reg;
  uint32 u32MbHandle;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  unsigned char _5;
  unsigned char _6;
  _Bool _7;
  <unnamed type> _8;
  <unnamed type> _9;
  unsigned char _10;
  <unnamed type> _11;

  <bb 2> :
  u32MbHandle_23 = 0;
  flag_reg_24 = 0;
  _1 = (int) instance_25(D);
  base_27 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_25(D);
  state_28 = Flexcan_Ip_apxState[_2];
  bIsSpuriousInt_29 = 1;
  mb_idx_31 = endMbIdx_30(D);
  _3 = instance_25(D) <= 2;
  DevAssert (_3);
  _4 = endMbIdx_30(D) <= 31;
  DevAssert (_4);
  if (state_28 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 3> :
  _5 = FlexCAN_GetMsgBuffIntStatusFlag (base_27, mb_idx_31);
  flag_reg_39 = (uint32) _5;
  goto <bb 5>; [INV]

  <bb 4> :
  mb_idx_40 = mb_idx_15 + 4294967295;
  _6 = FlexCAN_GetMsgBuffIntStatusFlag (base_27, mb_idx_40);
  flag_reg_42 = (uint32) _6;

  <bb 5> :
  # flag_reg_13 = PHI <flag_reg_39(3), flag_reg_42(4)>
  # mb_idx_15 = PHI <mb_idx_31(3), mb_idx_40(4)>
  if (flag_reg_13 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  if (mb_idx_15 > startMbIdx_34(D))
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  if (flag_reg_13 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 8> :
  bIsSpuriousInt_43 = 0;
  u32MbHandle_44 = mb_idx_15;
  _7 = state_28->bIsLegacyFifoEn;
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  if (mb_idx_15 <= 7)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  FlexCAN_IRQHandlerRxFIFO (instance_25(D), mb_idx_15);
  u32MbHandle_46 = 0;
  goto <bb 13>; [INV]

  <bb 11> :
  _8 ={v} state_28->mbs[u32MbHandle_44].state;
  if (_8 == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  FlexCAN_IRQHandlerRxMB (instance_25(D), mb_idx_15);

  <bb 13> :
  # u32MbHandle_12 = PHI <u32MbHandle_46(10), u32MbHandle_44(11), u32MbHandle_44(12)>
  _9 ={v} state_28->mbs[u32MbHandle_12].state;
  if (_9 == 2)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  FlexCAN_IRQHandlerTxMB (instance_25(D), mb_idx_15);

  <bb 15> :
  _10 = FlexCAN_GetMsgBuffIntStatusFlag (base_27, mb_idx_15);
  if (_10 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _11 ={v} state_28->mbs[u32MbHandle_12].state;
  if (_11 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  FlexCAN_ClearMsgBuffIntStatusFlag (base_27, mb_idx_15);

  <bb 18> :
  # bIsSpuriousInt_14 = PHI <bIsSpuriousInt_29(7), bIsSpuriousInt_43(15), bIsSpuriousInt_43(16), bIsSpuriousInt_43(17)>
  if (bIsSpuriousInt_14 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 19> :
  FlexCAN_ProcessSpuriousInterruptMB (instance_25(D), startMbIdx_34(D), endMbIdx_30(D));
  goto <bb 23>; [INV]

  <bb 20> :
  mb_idx_35 = startMbIdx_34(D);
  goto <bb 22>; [INV]

  <bb 21> :
  FlexCAN_ClearMsgBuffIntStatusFlag (base_27, mb_idx_16);
  mb_idx_37 = mb_idx_16 + 1;

  <bb 22> :
  # mb_idx_16 = PHI <mb_idx_35(20), mb_idx_37(21)>
  if (mb_idx_16 <= endMbIdx_30(D))
    goto <bb 21>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  return;

}


FlexCAN_CompleteRxMessageFifoData (uint8 instance)
{
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  _Bool _3;
  <unnamed type> _4;
  _Bool _5;
  _Bool _6;
  _Bool _7;

  <bb 2> :
  _1 = (int) instance_9(D);
  base_11 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_9(D);
  state_12 = Flexcan_Ip_apxState[_2];
  _3 = instance_9(D) <= 2;
  DevAssert (_3);
  _4 = state_12->transferType;
  if (_4 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = state_12->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_11, instance_9(D), 5, 0, _5);
  _6 = state_12->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_11, instance_9(D), 6, 0, _6);
  _7 = state_12->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_11, instance_9(D), 7, 0, _7);

  <bb 4> :
  state_12->mbs[0].pMBmessage = 0B;
  state_12->mbs[0].state ={v} 0;
  return;

}


FlexCAN_Ip_GetTransferStatus (uint8 instance, uint8 mb_idx)
{
  Flexcan_Ip_StatusType status;
  const struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType D.7805;
  int iftmp.7;
  int _1;
  _Bool _2;
  _Bool _3;
  int _4;
  <unnamed type> _5;
  int iftmp.7_7;
  int iftmp.7_14;
  int iftmp.7_15;
  Flexcan_Ip_StatusType _19;

  <bb 2> :
  _1 = (int) instance_8(D);
  state_10 = Flexcan_Ip_apxState[_1];
  status_11 = 1;
  _2 = instance_8(D) <= 2;
  DevAssert (_2);
  if (mb_idx_13(D) <= 31)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx_13(D) == 255)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.7_15 = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.7_14 = 0;

  <bb 6> :
  # iftmp.7_7 = PHI <iftmp.7_15(4), iftmp.7_14(5)>
  _3 = (_Bool) iftmp.7_7;
  DevAssert (_3);
  if (mb_idx_13(D) <= 31)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = (int) mb_idx_13(D);
  _5 ={v} state_10->mbs[_4].state;
  if (_5 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  status_18 = 0;
  goto <bb 10>; [INV]

  <bb 9> :
  status_17 = 2;

  <bb 10> :
  # status_6 = PHI <status_11(6), status_18(8), status_17(9)>
  _19 = status_6;

  <bb 11> :
<L9>:
  return _19;

}


FlexCAN_Ip_ConfigRemoteResponseMb (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  volatile uint32 * pMbAddr;
  const struct Flexcan_Ip_StateType * const state;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7792;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  long unsigned int _5;
  long unsigned int _6;
  _Bool _7;
  long unsigned int _8;
  unsigned char _9;
  long unsigned int _10;
  unsigned char _11;
  _Bool _12;
  _Bool _13;
  long unsigned int _14;
  _Bool _15;
  long unsigned int _16;
  <unnamed type> _17;
  long unsigned int _18;
  long unsigned int _19;
  _Bool _20;
  _Bool _21;
  _Bool _22;
  long unsigned int _23;
  _Bool _24;
  Flexcan_Ip_StatusType _57;

  <bb 2> :
  result_28 = 0;
  _1 = (int) instance_29(D);
  pBase_31 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_29(D);
  state_32 = Flexcan_Ip_apxState[_2];
  pMbAddr_33 = 0B;
  _3 = instance_29(D) <= 2;
  DevAssert (_3);
  _4 = tx_info_35(D) != 0B;
  DevAssert (_4);
  _5 ={v} pBase_31->CTRL2;
  _6 = _5 & 131072;
  _7 = _6 == 0;
  DevAssert (_7);
  _8 = tx_info_35(D)->data_length;
  _9 = (unsigned char) _8;
  _10 = (long unsigned int) mb_idx_38(D);
  _11 = FlexCAN_GetMbPayloadSize (pBase_31, _10);
  _12 = _9 <= _11;
  DevAssert (_12);
  _13 = state_32->bIsLegacyFifoEn;
  _14 = state_32->u32MaxMbNum;
  _15 = FlexCAN_IsMbOutOfRange (pBase_31, mb_idx_38(D), _13, _14);
  if (_15 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_42 = 4;

  <bb 4> :
  # result_25 = PHI <result_28(2), result_42(3)>
  if (result_25 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _16 = tx_info_35(D)->data_length;
  cs.dataLen = _16;
  _17 = tx_info_35(D)->msg_id_type;
  cs.msgIdType = _17;
  cs.code = 10;
  cs.fd_enable = 0;
  cs.enable_brs = 0;
  cs.fd_padding = 0;
  _18 = (long unsigned int) mb_idx_38(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_31, _18);
  _19 = (long unsigned int) mb_idx_38(D);
  pMbAddr_51 = FlexCAN_GetMsgBuffRegion (pBase_31, _19);
  _20 = tx_info_35(D)->is_remote;
  FlexCAN_SetTxMsgBuff (pMbAddr_51, &cs, msg_id_52(D), mb_data_53(D), _20);
  _21 = tx_info_35(D)->is_polling;
  _22 = ~_21;
  if (_22 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _23 = (long unsigned int) mb_idx_38(D);
  _24 = state_32->isIntActive;
  result_56 = FlexCAN_SetMsgBuffIntCmd (pBase_31, instance_29(D), _23, 1, _24);

  <bb 7> :
  # result_26 = PHI <result_25(4), result_25(5), result_56(6)>
  _57 = result_26;
  cs ={v} {CLOBBER};

  <bb 8> :
<L7>:
  return _57;

}


FlexCAN_Ip_ConfigRxFifo_Privileged (uint8 instance, Flexcan_Ip_RxFifoIdElementFormatType id_format, const struct Flexcan_Ip_IdTableType * id_filter_table)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7782;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _34;

  <bb 2> :
  _1 = instance_15(D) <= 2;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetRxFifoFilter (pBase_20, id_format_28(D), id_filter_table_29(D));

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_32 = FlexCAN_Disable (pBase_20);
  if (status_32 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_33 = status_32;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_33(11)>
  _34 = result_11;

  <bb 13> :
<L12>:
  return _34;

}


FlexCAN_Ip_RxFifoBlocking (uint8 instance, struct Flexcan_Ip_MsgBuffType * data, uint32 timeout)
{
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7768;
  _Bool _1;
  Flexcan_Ip_StatusType _14;

  <bb 2> :
  result_4 = 0;
  _1 = instance_5(D) <= 2;
  DevAssert (_1);
  result_10 = FlexCAN_StartRxMessageFifoData (instance_5(D), data_8(D));
  if (result_10 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_13 = FlexCAN_ProccessLegacyRxFIFO (instance_5(D), timeout_11(D));

  <bb 4> :
  # result_2 = PHI <result_10(2), result_13(3)>
  _14 = result_2;

  <bb 5> :
<L2>:
  return _14;

}


FlexCAN_Ip_RxFifo (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7764;
  _Bool _1;
  Flexcan_Ip_StatusType _9;

  <bb 2> :
  result_2 = 0;
  _1 = instance_3(D) <= 2;
  DevAssert (_1);
  result_8 = FlexCAN_StartRxMessageFifoData (instance_3(D), data_6(D));
  _9 = result_8;

  <bb 3> :
<L0>:
  return _9;

}


FlexCAN_Ip_ReceiveBlocking (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling, uint32 u32TimeoutMs)
{
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_StateType * state;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7761;
  long unsigned int D.7747;
  long unsigned int _1;
  _Bool _2;
  int _3;
  int _4;
  _Bool _5;
  long unsigned int _6;
  _Bool _7;
  long unsigned int _8;
  long unsigned int _9;
  unsigned char _10;
  long unsigned int _11;
  int _12;
  <unnamed type> _13;
  _Bool _14;
  long unsigned int _15;
  _Bool _16;
  int _17;
  <unnamed type> _18;
  int _19;
  long unsigned int _52;
  Flexcan_Ip_StatusType _59;

  <bb 2> :
  timeStart = 0;
  timeElapsed_32 = 0;
  _1 = u32TimeoutMs_33(D) * 1000;
  mS2Ticks_35 = OsIf_MicrosToTicks (_1, 0);
  _2 = instance_36(D) <= 2;
  DevAssert (_2);
  _3 = (int) instance_36(D);
  state_38 = Flexcan_Ip_apxState[_3];
  _4 = (int) instance_36(D);
  base_39 = Flexcan_Ip_apxBase[_4];
  result_44 = FlexCAN_StartRxMessageBufferData (instance_36(D), mb_idx_40(D), data_41(D), isPolling_42(D));
  if (result_44 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _5 = ~isPolling_42(D);
  if (_5 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = (long unsigned int) mb_idx_40(D);
  _7 = state_38->isIntActive;
  result_46 = FlexCAN_SetMsgBuffIntCmd (base_39, instance_36(D), _6, 1, _7);

  <bb 5> :
  # result_20 = PHI <result_44(2), result_44(3), result_46(4)>
  if (result_20 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _8 = OsIf_GetCounter (0);
  timeStart = _8;
  goto <bb 12>; [INV]

  <bb 7> :
  if (isPolling_42(D) != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _9 = (long unsigned int) mb_idx_40(D);
  _10 = FlexCAN_GetBuffStatusFlag (base_39, _9);
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _11 = (long unsigned int) mb_idx_40(D);
  FlexCAN_IRQHandlerRxMB (instance_36(D), _11);

  <bb 10> :
  _52 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_53 = _52 + timeElapsed_23;
  if (timeElapsed_53 >= mS2Ticks_35)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_54 = 3;
  goto <bb 13>; [INV]

  <bb 12> :
  # timeElapsed_23 = PHI <timeElapsed_32(6), timeElapsed_53(10)>
  _12 = (int) mb_idx_40(D);
  _13 ={v} state_38->mbs[_12].state;
  if (_13 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # result_21 = PHI <result_20(5), result_54(11), result_20(12)>
  if (result_21 == 3)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _14 = ~isPolling_42(D);
  if (_14 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _15 = (long unsigned int) mb_idx_40(D);
  _16 = state_38->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_39, instance_36(D), _15, 0, _16);

  <bb 16> :
  if (result_21 != 4)
    goto <bb 17>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 17> :
  if (result_21 != 2)
    goto <bb 18>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 18> :
  _17 = (int) mb_idx_40(D);
  _18 ={v} state_38->mbs[_17].state;
  if (_18 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  result_58 = 0;
  goto <bb 21>; [INV]

  <bb 20> :
  _19 = (int) mb_idx_40(D);
  state_38->mbs[_19].state ={v} 0;
  result_57 = 3;

  <bb 21> :
  # result_22 = PHI <result_21(16), result_21(17), result_58(19), result_57(20)>
  _59 = result_22;
  timeStart ={v} {CLOBBER};

  <bb 22> :
<L27>:
  return _59;

}


FlexCAN_Ip_Receive (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7735;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  long unsigned int _5;
  _Bool _6;
  Flexcan_Ip_StatusType _21;

  <bb 2> :
  _1 = (int) instance_9(D);
  base_11 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_9(D);
  state_12 = Flexcan_Ip_apxState[_2];
  _3 = instance_9(D) <= 2;
  DevAssert (_3);
  result_18 = FlexCAN_StartRxMessageBufferData (instance_9(D), mb_idx_14(D), data_15(D), isPolling_16(D));
  if (result_18 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _4 = ~isPolling_16(D);
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _5 = (long unsigned int) mb_idx_14(D);
  _6 = state_12->isIntActive;
  result_20 = FlexCAN_SetMsgBuffIntCmd (base_11, instance_9(D), _5, 1, _6);

  <bb 5> :
  # result_7 = PHI <result_18(2), result_18(3), result_20(4)>
  _21 = result_7;

  <bb 6> :
<L4>:
  return _21;

}


FlexCAN_Ip_ConfigRxMb (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * rx_info, uint32 msg_id)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7728;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  long unsigned int _6;
  _Bool _7;
  long unsigned int _8;
  long unsigned int _9;
  <unnamed type> _10;
  _Bool _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  Flexcan_Ip_StatusType _39;

  <bb 2> :
  eResult_17 = 0;
  _1 = (int) instance_18(D);
  base_20 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_18(D);
  state_21 = Flexcan_Ip_apxState[_2];
  _3 = instance_18(D) <= 2;
  DevAssert (_3);
  _4 = rx_info_23(D) != 0B;
  DevAssert (_4);
  _5 = state_21->bIsLegacyFifoEn;
  _6 = state_21->u32MaxMbNum;
  _7 = FlexCAN_IsMbOutOfRange (base_20, mb_idx_25(D), _5, _6);
  if (_7 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult_38 = 4;
  goto <bb 5>; [INV]

  <bb 4> :
  _8 = (long unsigned int) mb_idx_25(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_20, _8);
  _9 = rx_info_23(D)->data_length;
  cs.dataLen = _9;
  _10 = rx_info_23(D)->msg_id_type;
  cs.msgIdType = _10;
  _11 = rx_info_23(D)->fd_enable;
  cs.fd_enable = _11;
  cs.code = 15;
  _12 = (long unsigned int) mb_idx_25(D);
  FlexCAN_SetRxMsgBuff (base_20, _12, &cs, msg_id_32(D));
  cs.code = 0;
  _13 = (long unsigned int) mb_idx_25(D);
  FlexCAN_SetRxMsgBuff (base_20, _13, &cs, msg_id_32(D));
  cs.code = 4;
  _14 = (long unsigned int) mb_idx_25(D);
  FlexCAN_SetRxMsgBuff (base_20, _14, &cs, msg_id_32(D));

  <bb 5> :
  # eResult_15 = PHI <eResult_38(3), eResult_17(4)>
  _39 = eResult_15;
  cs ={v} {CLOBBER};

  <bb 6> :
<L4>:
  return _39;

}


FlexCAN_Ip_Send (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7721;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  _Bool _6;
  _Bool _7;
  _Bool _8;
  long unsigned int _9;
  _Bool _10;
  Flexcan_Ip_StatusType _29;

  <bb 2> :
  result_13 = 1;
  _1 = (int) instance_14(D);
  base_16 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_14(D);
  state_17 = Flexcan_Ip_apxState[_2];
  _3 = instance_14(D) <= 2;
  DevAssert (_3);
  _4 = tx_info_19(D) != 0B;
  DevAssert (_4);
  _5 = FlexCAN_IsListenOnlyModeEnabled (base_16);
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  result_26 = FlexCAN_StartSendData (instance_14(D), mb_idx_22(D), tx_info_19(D), msg_id_23(D), mb_data_24(D));
  if (result_26 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _7 = tx_info_19(D)->is_polling;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _9 = (long unsigned int) mb_idx_22(D);
  _10 = state_17->isIntActive;
  result_28 = FlexCAN_SetMsgBuffIntCmd (base_16, instance_14(D), _9, 1, _10);

  <bb 6> :
  # result_11 = PHI <result_13(2), result_26(3), result_26(4), result_28(5)>
  _29 = result_11;

  <bb 7> :
<L6>:
  return _29;

}


FlexCAN_Ip_Init_Privileged (uint8 Flexcan_Ip_u8Instance, struct Flexcan_Ip_StateType * Flexcan_Ip_pState, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  uint32 i;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7709;
  int _1;
  _Bool _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  _Bool _6;
  _Bool _7;
  _Bool _8;
  _Bool _9;
  const struct Flexcan_Ip_TimeSegmentType * _10;
  const struct Flexcan_Ip_TimeSegmentType * _11;
  const struct Flexcan_Ip_TimeSegmentType * _12;
  <unnamed type> _13;
  <unnamed type> _14;
  void (*<T626>) (uint8, Flexcan_Ip_EventType, uint32, const struct Flexcan_Ip_StateType *) _15;
  void (*<T626>) (uint8, Flexcan_Ip_EventType, uint32, const struct Flexcan_Ip_StateType *) _16;
  _Bool _17;
  long unsigned int _18;
  int _19;
  Flexcan_Ip_StatusType _57;

  <bb 2> :
  eResult_25 = 0;
  _1 = (int) Flexcan_Ip_u8Instance_26(D);
  pBase_28 = Flexcan_Ip_apxBase[_1];
  _2 = Flexcan_Ip_u8Instance_26(D) <= 2;
  DevAssert (_2);
  _3 = Flexcan_Ip_pData_30(D) != 0B;
  DevAssert (_3);
  _4 = Flexcan_Ip_pData_30(D)->fd_enable;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = FlexCAN_IsFDAvailable (pBase_28);
  _6 = Flexcan_Ip_pData_30(D)->fd_enable;
  _7 = _5 == _6;
  DevAssert (_7);

  <bb 4> :
  eResult_35 = FlexCAN_InitController (pBase_28, Flexcan_Ip_pData_30(D));
  if (eResult_35 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 5> :
  _8 = Flexcan_Ip_pData_30(D)->fd_enable;
  FlexCAN_EnableExtCbt (pBase_28, _8);
  _9 = Flexcan_Ip_pData_30(D)->fd_enable;
  if (_9 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _10 = &Flexcan_Ip_pData_30(D)->bitrate;
  FlexCAN_SetExtendedTimeSegments (pBase_28, _10);
  _11 = &Flexcan_Ip_pData_30(D)->bitrate_cbt;
  FlexCAN_SetFDTimeSegments (pBase_28, _11);
  goto <bb 8>; [INV]

  <bb 7> :
  _12 = &Flexcan_Ip_pData_30(D)->bitrate;
  FlexCAN_SetTimeSegments (pBase_28, _12);

  <bb 8> :
  _13 = Flexcan_Ip_pData_30(D)->flexcanMode;
  FlexCAN_SetOperationMode (pBase_28, _13);
  i_41 = 0;
  goto <bb 10>; [INV]

  <bb 9> :
  Flexcan_Ip_pState_42(D)->mbs[i_20].isPolling = 1;
  Flexcan_Ip_pState_42(D)->mbs[i_20].pMBmessage = 0B;
  Flexcan_Ip_pState_42(D)->mbs[i_20].state ={v} 0;
  Flexcan_Ip_pState_42(D)->mbs[i_20].time_stamp = 0;
  i_56 = i_20 + 1;

  <bb 10> :
  # i_20 = PHI <i_41(8), i_56(9)>
  if (i_20 <= 31)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _14 = Flexcan_Ip_pData_30(D)->transfer_type;
  Flexcan_Ip_pState_42(D)->transferType = _14;
  _15 = Flexcan_Ip_pData_30(D)->Callback;
  Flexcan_Ip_pState_42(D)->callback = _15;
  Flexcan_Ip_pState_42(D)->callbackParam = 0B;
  _16 = Flexcan_Ip_pData_30(D)->ErrorCallback;
  Flexcan_Ip_pState_42(D)->error_callback = _16;
  Flexcan_Ip_pState_42(D)->errorCallbackParam = 0B;
  _17 = Flexcan_Ip_pData_30(D)->is_rx_fifo_needed;
  Flexcan_Ip_pState_42(D)->bIsLegacyFifoEn = _17;
  _18 = Flexcan_Ip_pData_30(D)->max_num_mb;
  Flexcan_Ip_pState_42(D)->u32MaxMbNum = _18;
  Flexcan_Ip_pState_42(D)->isIntActive = 1;
  _19 = (int) Flexcan_Ip_u8Instance_26(D);
  Flexcan_Ip_apxState[_19] = Flexcan_Ip_pState_42(D);

  <bb 12> :
  _57 = eResult_35;

  <bb 13> :
<L10>:
  return _57;

}


FlexCAN_AbortRxTransfer (uint8 u8Instance, uint8 mb_idx)
{
  volatile uint32 * flexcan_mb;
  uint32 flexcan_mb_config;
  uint32 val2;
  uint32 val1;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  int _1;
  int _2;
  int _3;
  _Bool _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  _Bool _9;
  long unsigned int _10;
  long unsigned int _11;

  <bb 2> :
  _1 = (int) u8Instance_14(D);
  pBase_16 = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance_14(D);
  state_17 = Flexcan_Ip_apxState[_2];
  val1_18 = 0;
  val2_19 = 0;
  flexcan_mb_config_20 = 0;
  flexcan_mb_21 = 0B;
  _3 = (int) mb_idx_22(D);
  state_17->mbs[_3].state ={v} 0;
  _4 = state_17->bIsLegacyFifoEn;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _5 ={v} pBase_16->CTRL2;
  _6 = _5 >> 24;
  val1_33 = _6 & 15;
  val2_35 = RxFifoOcuppiedLastMsgBuff (val1_33);
  _7 = (long unsigned int) mb_idx_22(D);
  if (val2_35 < _7)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _8 = (long unsigned int) mb_idx_22(D);
  flexcan_mb_37 = FlexCAN_GetMsgBuffRegion (pBase_16, _8);
  flexcan_mb_config_38 ={v} *flexcan_mb_37;
  flexcan_mb_config_39 = flexcan_mb_config_38 & 4043309055;
  flexcan_mb_config_40 = flexcan_mb_config_39;
  *flexcan_mb_37 ={v} flexcan_mb_config_40;
  flexcan_mb_config_42 = flexcan_mb_config_40 & 4043309055;
  flexcan_mb_config_43 = flexcan_mb_config_42 | 67108864;
  *flexcan_mb_37 ={v} flexcan_mb_config_43;

  <bb 5> :
  if (mb_idx_22(D) == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _9 = state_17->isIntActive;
  FLEXCAN_ClearMsgBuffIntCmd (pBase_16, u8Instance_14(D), 5, _9);
  goto <bb 8>; [INV]

  <bb 7> :
  _10 = (long unsigned int) mb_idx_22(D);
  flexcan_mb_25 = FlexCAN_GetMsgBuffRegion (pBase_16, _10);
  flexcan_mb_config_26 ={v} *flexcan_mb_25;
  flexcan_mb_config_27 = flexcan_mb_config_26 & 4043309055;
  flexcan_mb_config_28 = flexcan_mb_config_27;
  *flexcan_mb_25 ={v} flexcan_mb_config_28;
  flexcan_mb_config_30 = flexcan_mb_config_28 & 4043309055;
  flexcan_mb_config_31 = flexcan_mb_config_30 | 67108864;
  *flexcan_mb_25 ={v} flexcan_mb_config_31;

  <bb 8> :
  _11 = (long unsigned int) mb_idx_22(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_16, _11);
  return;

}


FlexCAN_AbortTxTransfer (uint8 u8Instance, uint8 mb_idx)
{
  volatile uint32 * flexcan_mb;
  uint32 uS2Ticks;
  uint32 flexcan_mb_config;
  uint32 timeElapsed;
  uint32 timeStart;
  Flexcan_Ip_StatusType result;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.7690;
  long unsigned int D.7681;
  int _1;
  int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  unsigned char _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  int _12;
  long unsigned int _42;
  Flexcan_Ip_StatusType _50;

  <bb 2> :
  _1 = (int) u8Instance_19(D);
  pBase_21 = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance_19(D);
  state_22 = Flexcan_Ip_apxState[_2];
  result_23 = 0;
  timeStart = 0;
  timeElapsed_25 = 0;
  flexcan_mb_config_26 = 0;
  uS2Ticks_27 = 0;
  flexcan_mb_28 = 0B;
  _3 = (long unsigned int) mb_idx_29(D);
  flexcan_mb_31 = FlexCAN_GetMsgBuffRegion (pBase_21, _3);
  flexcan_mb_config_32 ={v} *flexcan_mb_31;
  flexcan_mb_config_33 = flexcan_mb_config_32 & 4043309055;
  flexcan_mb_config_34 = flexcan_mb_config_33 | 150994944;
  *flexcan_mb_31 ={v} flexcan_mb_config_34;
  uS2Ticks_37 = OsIf_MicrosToTicks (10000, 0);
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  goto <bb 5>; [INV]

  <bb 3> :
  _42 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_43 = _42 + timeElapsed_16;
  if (timeElapsed_43 >= uS2Ticks_37)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  result_44 = 3;
  goto <bb 6>; [INV]

  <bb 5> :
  # timeElapsed_16 = PHI <timeElapsed_25(2), timeElapsed_43(3)>
  _5 = (long unsigned int) mb_idx_29(D);
  _6 = FlexCAN_GetBuffStatusFlag (pBase_21, _5);
  if (_6 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  # result_13 = PHI <result_44(4), result_23(5)>
  if (result_13 != 3)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  flexcan_mb_config_45 ={v} *flexcan_mb_31;
  _7 = flexcan_mb_config_45 >> 24;
  _8 = _7 & 15;
  if (_8 == 8)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  result_46 = 5;

  <bb 9> :
  # result_14 = PHI <result_13(7), result_46(8)>
  _9 = flexcan_mb_config_45 >> 24;
  _10 = _9 & 15;
  if (_10 == 9)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  result_47 = 0;

  <bb 11> :
  # result_15 = PHI <result_13(6), result_14(9), result_47(10)>
  _11 = (long unsigned int) mb_idx_29(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_21, _11);
  _12 = (int) mb_idx_29(D);
  state_22->mbs[_12].state ={v} 0;
  _50 = result_15;
  timeStart ={v} {CLOBBER};

  <bb 12> :
<L12>:
  return _50;

}


FlexCAN_ProcessSpuriousInterruptMB (uint8 instance, uint32 startMbIdx, uint32 endMbIdx)
{
  uint32 u32MbHandle;
  uint32 mb_idx;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  unsigned char _3;
  unsigned char _4;
  _Bool _5;
  _Bool _6;
  _Bool _7;
  <unnamed type> _8;

  <bb 2> :
  _1 = (int) instance_13(D);
  base_15 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_13(D);
  state_16 = Flexcan_Ip_apxState[_2];
  mb_idx_17 = 0;
  u32MbHandle_18 = 0;
  mb_idx_20 = startMbIdx_19(D);
  goto <bb 12>; [INV]

  <bb 3> :
  _3 = FlexCAN_GetBuffStatusFlag (base_15, mb_idx_9);
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 4> :
  _4 = FlexCAN_GetBuffStatusImask (base_15, mb_idx_9);
  if (_4 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  u32MbHandle_24 = mb_idx_9;
  _5 = state_16->bIsLegacyFifoEn;
  if (_5 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (mb_idx_9 <= 7)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  u32MbHandle_25 = 0;

  <bb 8> :
  # u32MbHandle_10 = PHI <u32MbHandle_24(5), u32MbHandle_24(6), u32MbHandle_25(7)>
  _6 = state_16->mbs[u32MbHandle_10].isPolling;
  _7 = ~_6;
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  FlexCAN_ClearMsgBuffIntStatusFlag (base_15, mb_idx_9);
  _8 ={v} state_16->mbs[u32MbHandle_10].state;
  if (_8 == 2)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  state_16->mbs[u32MbHandle_10].state ={v} 0;
  state_16->mbs[u32MbHandle_10].isPolling = 1;

  <bb 11> :
  mb_idx_29 = mb_idx_9 + 1;

  <bb 12> :
  # mb_idx_9 = PHI <mb_idx_20(2), mb_idx_29(11)>
  if (mb_idx_9 <= endMbIdx_21(D))
    goto <bb 3>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  return;

}


FlexCAN_IRQHandlerRxFIFO (uint8 instance, uint32 mb_idx)
{
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  struct Flexcan_Ip_MsgBuffType * _3;
  <unnamed type> _4;
  struct Flexcan_Ip_MsgBuffType * _5;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _6;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _7;
  <unnamed type> _8;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _9;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _10;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _11;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _12;

  <bb 2> :
  _1 = (int) instance_19(D);
  base_21 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_19(D);
  state_22 = Flexcan_Ip_apxState[_2];
  _3 = state_22->mbs[0].pMBmessage;
  if (_3 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  state_22->mbs[0].pMBmessage = &data;

  <bb 4> :
  switch (mb_idx_24(D)) <default: <L15> [INV], case 5: <L2> [INV], case 6: <L9> [INV], case 7: <L12> [INV]>

  <bb 5> :
<L2>:
  _4 ={v} state_22->mbs[0].state;
  if (_4 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  _5 = state_22->mbs[0].pMBmessage;
  FlexCAN_ReadRxFifo (base_21, _5);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_21, mb_idx_24(D));
  state_22->mbs[0].state ={v} 0;
  _6 = state_22->callback;
  if (_6 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _7 = state_22->callback;
  _7 (instance_19(D), 1, 0, state_22);

  <bb 8> :
  _8 ={v} state_22->mbs[0].state;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  state_22->mbs[0].isPolling = 1;
  FlexCAN_CompleteRxMessageFifoData (instance_19(D));

  <bb 10> :
  goto <bb 18>; [INV]

  <bb 11> :
<L9>:
  FlexCAN_ClearMsgBuffIntStatusFlag (base_21, mb_idx_24(D));
  _9 = state_22->callback;
  if (_9 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _10 = state_22->callback;
  _10 (instance_19(D), 2, 0, state_22);

  <bb 13> :
  goto <bb 18>; [INV]

  <bb 14> :
<L12>:
  FlexCAN_ClearMsgBuffIntStatusFlag (base_21, mb_idx_24(D));
  _11 = state_22->callback;
  if (_11 != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _12 = state_22->callback;
  _12 (instance_19(D), 3, 0, state_22);

  <bb 16> :
  goto <bb 18>; [INV]

  <bb 17> :
<L15>:

  <bb 18> :
  data ={v} {CLOBBER};
  return;

}


FlexCAN_IRQHandlerTxMB (uint8 u8Instance, uint32 u32MbIdx)
{
  boolean bCurrentIntStat;
  struct Flexcan_Ip_MsgBuffType mb;
  struct Flexcan_Ip_StateType * pState;
  struct FLEXCAN_Type * pBase;
  int _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _9;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _10;
  <unnamed type> _11;
  _Bool _12;
  _Bool _13;
  _Bool _14;
  _Bool _15;
  _Bool _16;
  _Bool _17;

  <bb 2> :
  _1 = (int) u8Instance_21(D);
  pBase_23 = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance_21(D);
  pState_24 = Flexcan_Ip_apxState[_2];
  bCurrentIntStat_25 = 0;
  _3 = pState_24->mbs[u32MbIdx_26(D)].isRemote;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  FlexCAN_LockRxMsgBuff (pBase_23, u32MbIdx_26(D));
  FlexCAN_GetMsgBuff (pBase_23, u32MbIdx_26(D), &mb);
  FlexCAN_UnlockRxMsgBuff (pBase_23);
  _4 = mb.time_stamp;
  pState_24->mbs[u32MbIdx_26(D)].time_stamp = _4;
  _5 = mb.cs;
  _6 = _5 >> 24;
  _7 = _6 & 15;
  if (_7 == 4)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_23, u32MbIdx_26(D));
  goto <bb 6>; [INV]

  <bb 5> :
  _8 = FlexCAN_GetMsgBuffTimestamp (pBase_23, u32MbIdx_26(D));
  pState_24->mbs[u32MbIdx_26(D)].time_stamp = _8;
  FlexCAN_UnlockRxMsgBuff (pBase_23);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_23, u32MbIdx_26(D));

  <bb 6> :
  pState_24->mbs[u32MbIdx_26(D)].state ={v} 0;
  bCurrentIntStat_37 = pState_24->mbs[u32MbIdx_26(D)].isPolling;
  _9 = pState_24->callback;
  if (_9 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _10 = pState_24->callback;
  _10 (u8Instance_21(D), 4, u32MbIdx_26(D), pState_24);

  <bb 8> :
  _11 ={v} pState_24->mbs[u32MbIdx_26(D)].state;
  if (_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _12 = pState_24->mbs[u32MbIdx_26(D)].isPolling;
  _13 = ~_12;
  if (_13 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  pState_24->mbs[u32MbIdx_26(D)].isPolling = 1;
  _14 = pState_24->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_23, u8Instance_21(D), u32MbIdx_26(D), 0, _14);
  goto <bb 14>; [INV]

  <bb 11> :
  _15 = ~bCurrentIntStat_37;
  if (_15 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 12> :
  _16 = pState_24->mbs[u32MbIdx_26(D)].isPolling;
  if (_16 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _17 = pState_24->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_23, u8Instance_21(D), u32MbIdx_26(D), 0, _17);

  <bb 14> :
  mb ={v} {CLOBBER};
  return;

}


FlexCAN_IRQHandlerRxMB (uint8 instance, uint32 mb_idx)
{
  volatile uint32 * flexcan_mb;
  boolean bIsCriticalSectionNeeded;
  boolean bCurrentIntStat;
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  struct Flexcan_Ip_MsgBuffType * _3;
  _Bool _4;
  _Bool _5;
  struct Flexcan_Ip_MsgBuffType * _6;
  _Bool _7;
  struct Flexcan_Ip_MsgBuffType * _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _16;
  void (*<T620>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _17;
  <unnamed type> _18;
  _Bool _19;
  _Bool _20;
  _Bool _21;
  _Bool _22;
  _Bool _23;
  _Bool _24;

  <bb 2> :
  _1 = (int) instance_32(D);
  base_34 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_32(D);
  state_35 = Flexcan_Ip_apxState[_2];
  bCurrentIntStat_36 = 0;
  _3 = state_35->mbs[mb_idx_37(D)].pMBmessage;
  if (_3 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  state_35->mbs[mb_idx_37(D)].pMBmessage = &data;

  <bb 4> :
  bIsCriticalSectionNeeded_39 = 0;
  _4 = state_35->mbs[mb_idx_37(D)].isPolling;
  if (_4 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _5 = state_35->bIsLegacyFifoEn;
  if (_5 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  bIsCriticalSectionNeeded_40 = 1;
  __asm__ __volatile__(" cpsid i");

  <bb 7> :
  # bIsCriticalSectionNeeded_25 = PHI <bIsCriticalSectionNeeded_39(4), bIsCriticalSectionNeeded_39(5), bIsCriticalSectionNeeded_40(6)>
  FlexCAN_LockRxMsgBuff (base_34, mb_idx_37(D));
  _6 = state_35->mbs[mb_idx_37(D)].pMBmessage;
  FlexCAN_GetMsgBuff (base_34, mb_idx_37(D), _6);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_34, mb_idx_37(D));
  _7 = state_35->bIsLegacyFifoEn;
  if (_7 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _8 = state_35->mbs[mb_idx_37(D)].pMBmessage;
  _9 = _8->cs;
  _10 = _9 >> 24;
  _11 = _10 & 15;
  if (_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  flexcan_mb_46 = FlexCAN_GetMsgBuffRegion (base_34, mb_idx_37(D));
  _12 ={v} *flexcan_mb_46;
  _13 = _12 & 4043309055;
  *flexcan_mb_46 ={v} _13;
  _14 ={v} *flexcan_mb_46;
  _15 = _14 | 67108864;
  *flexcan_mb_46 ={v} _15;
  goto <bb 11>; [INV]

  <bb 10> :
  FlexCAN_UnlockRxMsgBuff (base_34);

  <bb 11> :
  if (bIsCriticalSectionNeeded_25 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  __asm__ __volatile__(" cpsie i");

  <bb 13> :
  state_35->mbs[mb_idx_37(D)].state ={v} 0;
  bCurrentIntStat_52 = state_35->mbs[mb_idx_37(D)].isPolling;
  _16 = state_35->callback;
  if (_16 != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _17 = state_35->callback;
  _17 (instance_32(D), 0, mb_idx_37(D), state_35);

  <bb 15> :
  _18 ={v} state_35->mbs[mb_idx_37(D)].state;
  if (_18 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _19 = state_35->mbs[mb_idx_37(D)].isPolling;
  _20 = ~_19;
  if (_20 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  state_35->mbs[mb_idx_37(D)].isPolling = 1;
  _21 = state_35->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_34, instance_32(D), mb_idx_37(D), 0, _21);
  goto <bb 21>; [INV]

  <bb 18> :
  _22 = ~bCurrentIntStat_52;
  if (_22 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  _23 = state_35->mbs[mb_idx_37(D)].isPolling;
  if (_23 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _24 = state_35->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_34, instance_32(D), mb_idx_37(D), 0, _24);

  <bb 21> :
  data ={v} {CLOBBER};
  return;

}


FlexCAN_StartRxMessageFifoData (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  Flexcan_Ip_StatusType eResult;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.7639;
  _Bool _1;
  int _2;
  int _3;
  _Bool _4;
  _Bool _5;
  <unnamed type> _6;
  <unnamed type> _7;
  <unnamed type> _8;
  _Bool _9;
  _Bool _10;
  _Bool _11;
  Flexcan_Ip_StatusType _33;

  <bb 2> :
  base_15 = 0B;
  state_16 = 0B;
  eResult_17 = 0;
  _1 = instance_18(D) <= 2;
  DevAssert (_1);
  _2 = (int) instance_18(D);
  base_21 = Flexcan_Ip_apxBase[_2];
  _3 = (int) instance_18(D);
  state_22 = Flexcan_Ip_apxState[_3];
  _4 = state_22->bIsLegacyFifoEn;
  _5 = ~_4;
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult_32 = 1;
  goto <bb 10>; [INV]

  <bb 4> :
  _6 ={v} state_22->mbs[0].state;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  eResult_31 = 2;
  goto <bb 10>; [INV]

  <bb 6> :
  state_22->mbs[0].state ={v} 1;
  _7 = state_22->transferType;
  if (_7 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  state_22->mbs[0].isPolling = 1;

  <bb 8> :
  state_22->mbs[0].pMBmessage = data_25(D);
  _8 = state_22->transferType;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  state_22->mbs[0].isPolling = 0;
  _9 = state_22->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_21, instance_18(D), 6, 1, _9);
  _10 = state_22->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_21, instance_18(D), 7, 1, _10);
  _11 = state_22->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_21, instance_18(D), 5, 1, _11);

  <bb 10> :
  # eResult_12 = PHI <eResult_32(3), eResult_31(5), eResult_17(8), eResult_17(9)>
  _33 = eResult_12;

  <bb 11> :
<L10>:
  return _33;

}


FlexCAN_StartSendData (uint8 Flexcan_Ip_u8Instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  volatile uint32 * pMbAddr;
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_StateType * state;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7626;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  long unsigned int _5;
  unsigned char _6;
  long unsigned int _7;
  unsigned char _8;
  _Bool _9;
  _Bool _10;
  long unsigned int _11;
  _Bool _12;
  int _13;
  <unnamed type> _14;
  long unsigned int _15;
  int _16;
  int _17;
  int _18;
  _Bool _19;
  int _20;
  _Bool _21;
  long unsigned int _22;
  <unnamed type> _23;
  _Bool _24;
  unsigned char _25;
  _Bool _26;
  _Bool _27;
  long unsigned int _28;
  Flexcan_Ip_StatusType _64;

  <bb 2> :
  eResult_32 = 0;
  _1 = (int) Flexcan_Ip_u8Instance_33(D);
  state_35 = Flexcan_Ip_apxState[_1];
  _2 = (int) Flexcan_Ip_u8Instance_33(D);
  base_36 = Flexcan_Ip_apxBase[_2];
  pMbAddr_37 = 0B;
  _3 = Flexcan_Ip_u8Instance_33(D) <= 2;
  DevAssert (_3);
  _4 = tx_info_39(D) != 0B;
  DevAssert (_4);
  _5 = tx_info_39(D)->data_length;
  _6 = (unsigned char) _5;
  _7 = (long unsigned int) mb_idx_41(D);
  _8 = FlexCAN_GetMbPayloadSize (base_36, _7);
  _9 = _6 <= _8;
  DevAssert (_9);
  _10 = state_35->bIsLegacyFifoEn;
  _11 = state_35->u32MaxMbNum;
  _12 = FlexCAN_IsMbOutOfRange (base_36, mb_idx_41(D), _10, _11);
  if (_12 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult_63 = 4;
  goto <bb 10>; [INV]

  <bb 4> :
  _13 = (int) mb_idx_41(D);
  _14 ={v} state_35->mbs[_13].state;
  if (_14 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  eResult_62 = 2;
  goto <bb 10>; [INV]

  <bb 6> :
  _15 = (long unsigned int) mb_idx_41(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_36, _15);
  _16 = (int) mb_idx_41(D);
  state_35->mbs[_16].state ={v} 2;
  _17 = (int) mb_idx_41(D);
  state_35->mbs[_17].time_stamp = 0;
  _18 = (int) mb_idx_41(D);
  _19 = tx_info_39(D)->is_polling;
  state_35->mbs[_18].isPolling = _19;
  _20 = (int) mb_idx_41(D);
  _21 = tx_info_39(D)->is_remote;
  state_35->mbs[_20].isRemote = _21;
  _22 = tx_info_39(D)->data_length;
  cs.dataLen = _22;
  _23 = tx_info_39(D)->msg_id_type;
  cs.msgIdType = _23;
  _24 = tx_info_39(D)->fd_enable;
  cs.fd_enable = _24;
  _25 = tx_info_39(D)->fd_padding;
  cs.fd_padding = _25;
  _26 = tx_info_39(D)->enable_brs;
  cs.enable_brs = _26;
  _27 = tx_info_39(D)->is_remote;
  if (_27 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  cs.code = 28;
  goto <bb 9>; [INV]

  <bb 8> :
  cs.code = 12;

  <bb 9> :
  _28 = (long unsigned int) mb_idx_41(D);
  pMbAddr_58 = FlexCAN_GetMsgBuffRegion (base_36, _28);
  FlexCAN_SetTxMsgBuff (pMbAddr_58, &cs, msg_id_59(D), mb_data_60(D), 0);

  <bb 10> :
  # eResult_29 = PHI <eResult_63(3), eResult_62(5), eResult_32(9)>
  _64 = eResult_29;
  cs ={v} {CLOBBER};

  <bb 11> :
<L10>:
  return _64;

}


FlexCAN_StartRxMessageBufferData (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling)
{
  struct Flexcan_Ip_StateType * state;
  const struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7612;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  long unsigned int _5;
  _Bool _6;
  int _7;
  <unnamed type> _8;
  int _9;
  int _10;
  int _11;
  Flexcan_Ip_StatusType _29;

  <bb 2> :
  result_14 = 0;
  _1 = (int) instance_15(D);
  base_17 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_15(D);
  state_18 = Flexcan_Ip_apxState[_2];
  _3 = instance_15(D) <= 2;
  DevAssert (_3);
  _4 = state_18->bIsLegacyFifoEn;
  _5 = state_18->u32MaxMbNum;
  _6 = FlexCAN_IsMbOutOfRange (base_17, mb_idx_20(D), _4, _5);
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_28 = 4;
  goto <bb 7>; [INV]

  <bb 4> :
  _7 = (int) mb_idx_20(D);
  _8 ={v} state_18->mbs[_7].state;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  result_27 = 2;
  goto <bb 7>; [INV]

  <bb 6> :
  _9 = (int) mb_idx_20(D);
  state_18->mbs[_9].state ={v} 1;
  _10 = (int) mb_idx_20(D);
  state_18->mbs[_10].pMBmessage = data_23(D);
  _11 = (int) mb_idx_20(D);
  state_18->mbs[_11].isPolling = isPolling_25(D);

  <bb 7> :
  # result_12 = PHI <result_28(3), result_27(5), result_14(6)>
  _29 = result_12;

  <bb 8> :
<L6>:
  return _29;

}


FlexCAN_ProccessLegacyRxFIFO (uint8 u8Instance, uint32 u32TimeoutMs)
{
  uint32 u32intType;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_StateType * pState;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7585;
  long unsigned int D.7578;
  int _1;
  int _2;
  long unsigned int _3;
  long unsigned int _4;
  <unnamed type> _5;
  unsigned char _6;
  <unnamed type> _7;
  <unnamed type> _8;
  _Bool _9;
  _Bool _10;
  _Bool _11;
  <unnamed type> _12;
  long unsigned int _42;
  Flexcan_Ip_StatusType _51;

  <bb 2> :
  eResult_24 = 0;
  _1 = (int) u8Instance_25(D);
  pState_27 = Flexcan_Ip_apxState[_1];
  _2 = (int) u8Instance_25(D);
  pBase_28 = Flexcan_Ip_apxBase[_2];
  timeStart = 0;
  timeElapsed_30 = 0;
  _3 = u32TimeoutMs_31(D) * 1000;
  mS2Ticks_33 = OsIf_MicrosToTicks (_3, 0);
  u32intType_34 = 0;
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  goto <bb 11>; [INV]

  <bb 3> :
  _5 = pState_27->transferType;
  if (_5 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  u32intType_37 = 7;
  goto <bb 8>; [INV]

  <bb 5> :
  _6 = FlexCAN_GetBuffStatusFlag (pBase_28, u32intType_16);
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_IRQHandlerRxFIFO (u8Instance_25(D), u32intType_16);

  <bb 7> :
  u32intType_40 = u32intType_16 + 4294967295;

  <bb 8> :
  # u32intType_16 = PHI <u32intType_37(4), u32intType_40(7)>
  if (u32intType_16 > 4)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _42 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_43 = _42 + timeElapsed_15;
  if (timeElapsed_43 >= mS2Ticks_33)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  eResult_44 = 3;
  goto <bb 12>; [INV]

  <bb 11> :
  # timeElapsed_15 = PHI <timeElapsed_30(2), timeElapsed_43(9)>
  _7 ={v} pState_27->mbs[0].state;
  if (_7 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  # eResult_13 = PHI <eResult_44(10), eResult_24(11)>
  if (eResult_13 == 3)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _8 = pState_27->transferType;
  if (_8 != 1)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _9 = pState_27->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_28, u8Instance_25(D), 5, 0, _9);
  _10 = pState_27->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_28, u8Instance_25(D), 6, 0, _10);
  _11 = pState_27->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_28, u8Instance_25(D), 7, 0, _11);

  <bb 15> :
  _12 ={v} pState_27->mbs[0].state;
  switch (_12) <default: <L18> [INV], case 0: <L17> [INV], case 1: <L16> [INV]>

  <bb 16> :
<L16>:
  pState_27->mbs[0].state ={v} 0;
  goto <bb 19>; [INV]

  <bb 17> :
<L17>:
  eResult_49 = 0;
  goto <bb 19>; [INV]

  <bb 18> :
<L18>:
  eResult_50 = 1;

  <bb 19> :
  # eResult_14 = PHI <eResult_13(16), eResult_49(17), eResult_50(18)>
  _51 = eResult_14;
  timeStart ={v} {CLOBBER};

  <bb 20> :
<L21>:
  return _51;

}


FlexCAN_InitController (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7558;
  _Bool _1;
  _Bool _2;
  long unsigned int _3;
  long unsigned int _4;
  _Bool _5;
  _Bool _6;
  _Bool _7;
  long unsigned int _8;
  Flexcan_Ip_StatusType _34;

  <bb 2> :
  eResult_14 = 0;
  _1 = FlexCAN_IsEnabled (pBase_16(D));
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  eResult_19 = FlexCAN_EnterFreezeMode (pBase_16(D));
  if (eResult_19 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  eResult_21 = FlexCAN_Disable (pBase_16(D));

  <bb 5> :
  # eResult_9 = PHI <eResult_14(2), eResult_19(3), eResult_21(4)>
  if (eResult_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 6> :
  _2 = Flexcan_Ip_pData_22(D)->is_pe_clock;
  FlexCAN_SetClkSrc (pBase_16(D), _2);
  _3 ={v} pBase_16(D)->MCR;
  _4 = _3 & 2147483647;
  pBase_16(D)->MCR ={v} _4;
  eResult_26 = FlexCAN_Init (pBase_16(D));
  if (eResult_26 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  FlexCAN_EnterFreezeMode (pBase_16(D));
  FlexCAN_Disable (pBase_16(D));
  goto <bb 11>; [INV]

  <bb 8> :
  _5 = FlexCAN_IsFDAvailable (pBase_16(D));
  if (_5 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = Flexcan_Ip_pData_22(D)->fd_enable;
  _7 = Flexcan_Ip_pData_22(D)->bitRateSwitch;
  FlexCAN_SetFDEnabled (pBase_16(D), _6, _7);

  <bb 10> :
  _8 = Flexcan_Ip_pData_22(D)->ctrlOptions;
  FlexCAN_ConfigCtrlOptions (pBase_16(D), _8);
  eResult_31 = FlexCAN_InitCtroll (pBase_16(D), Flexcan_Ip_pData_22(D));

  <bb 11> :
  # eResult_10 = PHI <eResult_9(5), eResult_26(7), eResult_31(10)>
  _34 = eResult_10;

  <bb 12> :
<L11>:
  return _34;

}


FlexCAN_InitCtroll (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7541;
  <unnamed type> _1;
  const struct Flexcan_Ip_PayloadSizeType * _2;
  long unsigned int _3;
  Flexcan_Ip_StatusType _21;

  <bb 2> :
  eResult_7 = 0;
  _1 = Flexcan_Ip_pData_9(D)->flexcanMode;
  if (_1 != 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_SetSelfReception (pBase_10(D), 0);

  <bb 4> :
  eResult_13 = FlexCAN_InitRxFifo (pBase_10(D), Flexcan_Ip_pData_9(D));
  if (eResult_13 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  FlexCAN_EnterFreezeMode (pBase_10(D));
  FlexCAN_Disable (pBase_10(D));
  goto <bb 8>; [INV]

  <bb 6> :
  _2 = &Flexcan_Ip_pData_9(D)->payload;
  FlexCAN_SetPayloadSize (pBase_10(D), _2);
  _3 = Flexcan_Ip_pData_9(D)->max_num_mb;
  eResult_16 = FlexCAN_SetMaxMsgBuffNum (pBase_10(D), _3);
  if (eResult_16 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  FlexCAN_EnterFreezeMode (pBase_10(D));
  FlexCAN_Disable (pBase_10(D));

  <bb 8> :
  # eResult_4 = PHI <eResult_13(5), eResult_16(6), eResult_16(7)>
  _21 = eResult_4;

  <bb 9> :
<L7>:
  return _21;

}


FlexCAN_InitRxFifo (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7532;
  _Bool _1;
  <unnamed type> _2;
  Flexcan_Ip_StatusType _11;

  <bb 2> :
  eResult_5 = 0;
  _1 = Flexcan_Ip_pData_7(D)->is_rx_fifo_needed;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = Flexcan_Ip_pData_7(D)->num_id_filters;
  eResult_10 = FlexCAN_EnableRxFifo (pBase_8(D), _2);

  <bb 4> :
  # eResult_3 = PHI <eResult_5(2), eResult_10(3)>
  _11 = eResult_3;

  <bb 5> :
<L2>:
  return _11;

}


FlexCAN_SetRegDefaultVal (struct FLEXCAN_Type * base)
{
  _Bool _1;

  <bb 2> :
  _1 = FlexCAN_IsFDAvailable (base_4(D));
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  base_4(D)->FDCBT ={v} 0;
  base_4(D)->FDCTRL ={v} 2147500288;

  <bb 4> :
  base_4(D)->IFLAG1 ={v} 4294967295;
  base_4(D)->IMASK1 ={v} 0;
  base_4(D)->CBT ={v} 0;
  base_4(D)->CTRL2 ={v} 1048576;
  base_4(D)->ESR1 ={v} 241670;
  base_4(D)->ECR ={v} 0;
  base_4(D)->TIMER ={v} 0;
  base_4(D)->CTRL1 ={v} 0;
  base_4(D)->MCR ={v} 3633315855;
  return;

}


FlexCAN_SetRxMaskType (struct FLEXCAN_Type * base, Flexcan_Ip_RxMaskType type)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;

  <bb 2> :
  if (type_6(D) == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 ={v} base_8(D)->MCR;
  _2 = _1 & 4294901759;
  base_8(D)->MCR ={v} _2;
  goto <bb 5>; [INV]

  <bb 4> :
  _3 ={v} base_8(D)->MCR;
  _4 = _3 | 65536;
  base_8(D)->MCR ={v} _4;

  <bb 5> :
  return;

}


FlexCAN_SetTxArbitrationStartDelay (struct FLEXCAN_Type * base, uint8 tasd)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;

  <bb 2> :
  _1 ={v} base_8(D)->CTRL2;
  _2 = _1 & 4278714367;
  _3 = (long unsigned int) tasd_9(D);
  _4 = _3 << 19;
  _5 = _4 & 16252928;
  _6 = _2 | _5;
  base_8(D)->CTRL2 ={v} _6;
  return;

}


FlexCAN_IsFreezeMode (const struct FLEXCAN_Type * base)
{
  boolean D.7784;
  long unsigned int _1;
  long unsigned int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} base_4(D)->MCR;
  _2 = _1 & 16777216;
  _5 = _2 != 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_SetRxIndividualMask (struct FLEXCAN_Type * base, uint32 msgBuffIdx, uint32 mask)
{
  <bb 2> :
  base_2(D)->RXIMR[msgBuffIdx_3(D)] ={v} mask_4(D);
  return;

}


FlexCAN_SetRxMsgBuffGlobalMask (struct FLEXCAN_Type * base, uint32 Mask)
{
  <bb 2> :
  base_2(D)->RXMGMASK ={v} Mask_3(D);
  return;

}


FlexCAN_GetMsgBuffIntStatusFlag (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 mask;
  uint8 flag;
  uint8 D.7831;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  unsigned char _5;
  uint8 _13;

  <bb 2> :
  flag_7 = 0;
  if (msgBuffIdx_8(D) <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  mask_11 ={v} base_10(D)->IMASK1;
  _1 ={v} base_10(D)->IFLAG1;
  _2 = mask_11 & _1;
  _3 = msgBuffIdx_8(D) & 31;
  _4 = _2 >> _3;
  _5 = (unsigned char) _4;
  flag_12 = _5 & 1;

  <bb 4> :
  # flag_6 = PHI <flag_7(2), flag_12(3)>
  _13 = flag_6;

  <bb 5> :
<L2>:
  return _13;

}


FlexCAN_SetClkSrc (struct FLEXCAN_Type * base, boolean enable)
{
  long unsigned int iftmp.1;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int iftmp.1_4;
  long unsigned int iftmp.1_8;
  long unsigned int iftmp.1_9;

  <bb 2> :
  _1 ={v} base_6(D)->CTRL1;
  _2 = _1 & 4294959103;
  if (enable_7(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.1_9 = 8192;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.1_8 = 0;

  <bb 5> :
  # iftmp.1_4 = PHI <iftmp.1_9(3), iftmp.1_8(4)>
  _3 = iftmp.1_4 | _2;
  base_6(D)->CTRL1 ={v} _3;
  return;

}


RxFifoOcuppiedLastMsgBuff (uint32 x)
{
  uint32 D.7700;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  uint32 _5;

  <bb 2> :
  _1 = x_4(D) + 1;
  _2 = _1 * 8;
  _3 = _2 / 4;
  _5 = _3 + 5;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_IsListenOnlyModeEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.7723;
  long unsigned int _1;
  long unsigned int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} base_4(D)->CTRL1;
  _2 = _1 & 8;
  _5 = _2 != 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_IsFDEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.8057;
  long unsigned int _1;
  long unsigned int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} base_4(D)->MCR;
  _2 = _1 & 2048;
  _5 = _2 != 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_SetSelfReception (struct FLEXCAN_Type * base, boolean enable)
{
  long unsigned int iftmp.0;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int iftmp.0_4;
  long unsigned int iftmp.0_8;
  long unsigned int iftmp.0_9;

  <bb 2> :
  _1 ={v} base_6(D)->MCR;
  _2 = _1 & 4294836223;
  if (enable_7(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0_9 = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0_8 = 131072;

  <bb 5> :
  # iftmp.0_4 = PHI <iftmp.0_9(3), iftmp.0_8(4)>
  _3 = iftmp.0_4 | _2;
  base_6(D)->MCR ={v} _3;
  return;

}


FlexCAN_EnableExtCbt (struct FLEXCAN_Type * base, boolean enableCBT)
{
  long unsigned int iftmp.6;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int iftmp.6_4;
  long unsigned int iftmp.6_8;
  long unsigned int iftmp.6_9;

  <bb 2> :
  _1 ={v} base_6(D)->CBT;
  _2 = _1 & 2147483647;
  if (enableCBT_7(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.6_9 = 2147483648;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.6_8 = 0;

  <bb 5> :
  # iftmp.6_4 = PHI <iftmp.6_9(3), iftmp.6_8(4)>
  _3 = iftmp.6_4 | _2;
  base_6(D)->CBT ={v} _3;
  return;

}


FlexCAN_IsExCbtEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.8032;
  long unsigned int _1;
  signed int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} pBase_4(D)->CBT;
  _2 = (signed int) _1;
  _5 = _2 < 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_GetFDTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;

  <bb 2> :
  _1 ={v} base_16(D)->FDCBT;
  _2 = _1 >> 20;
  _3 = _2 & 1023;
  timeSeg_17(D)->preDivider = _3;
  _4 ={v} base_16(D)->FDCBT;
  _5 = _4 >> 10;
  _6 = _5 & 31;
  timeSeg_17(D)->propSeg = _6;
  _7 ={v} base_16(D)->FDCBT;
  _8 = _7 >> 5;
  _9 = _8 & 7;
  timeSeg_17(D)->phaseSeg1 = _9;
  _10 ={v} base_16(D)->FDCBT;
  _11 = _10 & 7;
  timeSeg_17(D)->phaseSeg2 = _11;
  _12 ={v} base_16(D)->FDCBT;
  _13 = _12 >> 16;
  _14 = _13 & 7;
  timeSeg_17(D)->rJumpwidth = _14;
  return;

}


FlexCAN_GetTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;

  <bb 2> :
  _1 ={v} base_16(D)->CTRL1;
  _2 = _1 >> 24;
  _3 = _2 & 255;
  timeSeg_17(D)->preDivider = _3;
  _4 ={v} base_16(D)->CTRL1;
  _5 = _4 & 7;
  timeSeg_17(D)->propSeg = _5;
  _6 ={v} base_16(D)->CTRL1;
  _7 = _6 >> 19;
  _8 = _7 & 7;
  timeSeg_17(D)->phaseSeg1 = _8;
  _9 ={v} base_16(D)->CTRL1;
  _10 = _9 >> 16;
  _11 = _10 & 7;
  timeSeg_17(D)->phaseSeg2 = _11;
  _12 ={v} base_16(D)->CTRL1;
  _13 = _12 >> 22;
  _14 = _13 & 3;
  timeSeg_17(D)->rJumpwidth = _14;
  return;

}


FlexCAN_GetExtendedTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;

  <bb 2> :
  _1 ={v} base_16(D)->CBT;
  _2 = _1 >> 21;
  _3 = _2 & 1023;
  timeSeg_17(D)->preDivider = _3;
  _4 ={v} base_16(D)->CBT;
  _5 = _4 >> 10;
  _6 = _5 & 63;
  timeSeg_17(D)->propSeg = _6;
  _7 ={v} base_16(D)->CBT;
  _8 = _7 >> 5;
  _9 = _8 & 31;
  timeSeg_17(D)->phaseSeg1 = _9;
  _10 ={v} base_16(D)->CBT;
  _11 = _10 & 31;
  timeSeg_17(D)->phaseSeg2 = _11;
  _12 ={v} base_16(D)->CBT;
  _13 = _12 >> 16;
  _14 = _13 & 31;
  timeSeg_17(D)->rJumpwidth = _14;
  return;

}


FlexCAN_SetExtendedTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _23;

  <bb 2> :
  _1 = timeSeg_24(D) != 0B;
  DevAssert (_1);
  _2 ={v} base_27(D)->CBT;
  _3 = _2 & 2147483648;
  base_27(D)->CBT ={v} _3;
  _4 ={v} base_27(D)->CBT;
  _5 = timeSeg_24(D)->propSeg;
  _6 = _5 << 10;
  _7 = _6 & 65535;
  _8 = timeSeg_24(D)->phaseSeg2;
  _9 = _8 & 31;
  _10 = _7 | _9;
  _11 = timeSeg_24(D)->phaseSeg1;
  _12 = _11 << 5;
  _13 = _12 & 992;
  _14 = _10 | _13;
  _15 = timeSeg_24(D)->preDivider;
  _16 = _15 << 21;
  _17 = _16 & 2145386496;
  _18 = _14 | _17;
  _19 = timeSeg_24(D)->rJumpwidth;
  _20 = _19 << 16;
  _21 = _20 & 2031616;
  _22 = _18 | _21;
  _23 = _4 | _22;
  base_27(D)->CBT ={v} _23;
  return;

}


FlexCAN_SetTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;

  <bb 2> :
  _1 = timeSeg_23(D) != 0B;
  DevAssert (_1);
  _2 ={v} base_26(D)->CTRL1;
  _3 = _2 & 65528;
  base_26(D)->CTRL1 ={v} _3;
  _4 ={v} base_26(D)->CTRL1;
  _5 = timeSeg_23(D)->propSeg;
  _6 = _5 & 7;
  _7 = timeSeg_23(D)->phaseSeg2;
  _8 = _7 << 16;
  _9 = _8 & 458752;
  _10 = _6 | _9;
  _11 = timeSeg_23(D)->phaseSeg1;
  _12 = _11 << 19;
  _13 = _12 & 3670016;
  _14 = _10 | _13;
  _15 = timeSeg_23(D)->preDivider;
  _16 = _15 << 24;
  _17 = _14 | _16;
  _18 = timeSeg_23(D)->rJumpwidth;
  _19 = _18 << 22;
  _20 = _19 & 12582912;
  _21 = _17 | _20;
  _22 = _4 | _21;
  base_26(D)->CTRL1 ={v} _22;
  return;

}


FlexCAN_SetFDTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _23;

  <bb 2> :
  _1 = timeSeg_24(D) != 0B;
  DevAssert (_1);
  _2 ={v} base_27(D)->FDCBT;
  _3 = _2 & 3221783320;
  base_27(D)->FDCBT ={v} _3;
  _4 ={v} base_27(D)->FDCBT;
  _5 = timeSeg_24(D)->propSeg;
  _6 = _5 << 10;
  _7 = _6 & 31744;
  _8 = timeSeg_24(D)->phaseSeg2;
  _9 = _8 & 7;
  _10 = _7 | _9;
  _11 = timeSeg_24(D)->phaseSeg1;
  _12 = _11 << 5;
  _13 = _12 & 255;
  _14 = _10 | _13;
  _15 = timeSeg_24(D)->preDivider;
  _16 = _15 << 20;
  _17 = _16 & 1072693248;
  _18 = _14 | _17;
  _19 = timeSeg_24(D)->rJumpwidth;
  _20 = _19 << 16;
  _21 = _20 & 458752;
  _22 = _18 | _21;
  _23 = _4 | _22;
  base_27(D)->FDCBT ={v} _23;
  return;

}


FlexCAN_GetBuffStatusImask (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 u32Imask;
  uint8 D.7847;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  uint8 _12;

  <bb 2> :
  u32Imask_7 = 0;
  if (msgBuffIdx_8(D) <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 ={v} base_10(D)->IMASK1;
  _2 = msgBuffIdx_8(D) & 31;
  _3 = 1 << _2;
  _4 = _1 & _3;
  _5 = msgBuffIdx_8(D) & 31;
  u32Imask_11 = _4 >> _5;

  <bb 4> :
  # u32Imask_6 = PHI <u32Imask_7(2), u32Imask_11(3)>
  _12 = (uint8) u32Imask_6;

  <bb 5> :
<L2>:
  return _12;

}


FlexCAN_GetBuffStatusFlag (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 flag;
  uint8 D.7590;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  uint8 _12;

  <bb 2> :
  flag_7 = 0;
  if (msgBuffIdx_8(D) <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 ={v} base_10(D)->IFLAG1;
  _2 = msgBuffIdx_8(D) & 31;
  _3 = 1 << _2;
  _4 = _1 & _3;
  _5 = msgBuffIdx_8(D) & 31;
  flag_11 = _4 >> _5;

  <bb 4> :
  # flag_6 = PHI <flag_7(2), flag_11(3)>
  _12 = (uint8) flag_6;

  <bb 5> :
<L2>:
  return _12;

}


FlexCAN_ClearMsgBuffIntStatusFlag (struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 flag;
  long unsigned int _1;

  <bb 2> :
  _1 = msgBuffIdx_3(D) & 31;
  flag_4 = 1 << _1;
  if (msgBuffIdx_3(D) <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  base_6(D)->IFLAG1 ={v} flag_4;

  <bb 4> :
  return;

}


FlexCAN_UnlockRxMsgBuff (const struct FLEXCAN_Type * base)
{
  long unsigned int vol.5;
  long unsigned int vol.5_3;

  <bb 2> :
  vol.5_3 ={v} base_2(D)->TIMER;
  return;

}


FlexCAN_SetListenOnlyMode (struct FLEXCAN_Type * base, boolean enableListenOnly)
{
  long unsigned int iftmp.9;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int iftmp.9_4;
  long unsigned int iftmp.9_8;
  long unsigned int iftmp.9_9;

  <bb 2> :
  _1 ={v} base_6(D)->CTRL1;
  _2 = _1 & 4294967287;
  if (enableListenOnly_7(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.9_9 = 8;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.9_8 = 0;

  <bb 5> :
  # iftmp.9_4 = PHI <iftmp.9_9(3), iftmp.9_8(4)>
  _3 = iftmp.9_4 | _2;
  base_6(D)->CTRL1 ={v} _3;
  return;

}


FlexCAN_SetFDEnabled (struct FLEXCAN_Type * base, boolean enableFD, boolean enableBRS)
{
  long unsigned int iftmp.3;
  long unsigned int iftmp.2;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int iftmp.2_9;
  long unsigned int iftmp.3_10;
  long unsigned int iftmp.2_14;
  long unsigned int iftmp.2_15;
  long unsigned int iftmp.3_18;
  long unsigned int iftmp.3_19;

  <bb 2> :
  _1 ={v} base_12(D)->MCR;
  _2 = _1 & 4294965247;
  if (enableFD_13(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.2_15 = 2048;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.2_14 = 0;

  <bb 5> :
  # iftmp.2_9 = PHI <iftmp.2_15(3), iftmp.2_14(4)>
  _3 = iftmp.2_9 | _2;
  base_12(D)->MCR ={v} _3;
  _4 ={v} base_12(D)->FDCTRL;
  _5 = _4 & 2147483647;
  if (enableBRS_17(D) != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  iftmp.3_19 = 2147483648;
  goto <bb 8>; [INV]

  <bb 7> :
  iftmp.3_18 = 0;

  <bb 8> :
  # iftmp.3_10 = PHI <iftmp.3_19(6), iftmp.3_18(7)>
  _6 = iftmp.3_10 | _5;
  base_12(D)->FDCTRL ={v} _6;
  _7 ={v} base_12(D)->FDCTRL;
  _8 = _7 & 4294926591;
  base_12(D)->FDCTRL ={v} _8;
  return;

}


FlexCAN_IsEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.7560;
  long unsigned int _1;
  signed int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} pBase_4(D)->MCR;
  _2 = (signed int) _1;
  _5 = _2 >= 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_SetTDCOffset (struct FLEXCAN_Type * base, boolean enable, uint8 offset)
{
  uint32 tmp;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;

  <bb 2> :
  tmp_7 ={v} base_6(D)->FDCTRL;
  tmp_8 = tmp_7 & 4294926591;
  if (enable_9(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  tmp_10 = tmp_8 | 32768;
  _1 = (long unsigned int) offset_11(D);
  _2 = _1 << 8;
  _3 = _2 & 7936;
  tmp_12 = tmp_10 | _3;

  <bb 4> :
  # tmp_4 = PHI <tmp_8(2), tmp_12(3)>
  base_6(D)->FDCTRL ={v} tmp_4;
  return;

}


FlexCAN_SetRxFifoGlobalMask (struct FLEXCAN_Type * base, uint32 Mask)
{
  <bb 2> :
  base_2(D)->RXFGMASK ={v} Mask_3(D);
  return;

}


DevAssert (volatile boolean x)
{
  _Bool x.4_1;

  <bb 2> :
  x.4_1 ={v} x;
  if (x.4_1 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  goto <bb 3>; [INV]

  <bb 4> :
  return;

}


